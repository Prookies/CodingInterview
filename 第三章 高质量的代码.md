# 高质量的代码

## 面试官谈代码质量

**注意事项**

由于精度原因，不能用等号判断两个小数是否相等

边界情况

异常状况

变量和函数的命名

## 代码的规范性

书写、布局和命名都决定着代码的规范性。

首先，规范的代码书写清晰。绝大部分面试都是要求应聘者在白纸或者白班上书写。面试过程中可以减慢写字的速度，尽量把每个字母都写清楚。最重要的是在写代码之前形成清晰的思路并能把思路用编程语言清楚地书写出来。

其次，规范的代码布局清晰。平时程序员在集成开发环境如Visual Studio里面写代码，依靠专业工具调整代码的布局，加入合理的缩进并让括号成对呈现。离开了这些工具手写代码，我们就要格外注意布局问题。

最后，规范的代码命名合理。强烈建议应聘者在写代码的时候，用完整的英文单词组合命名变量和函数。如果一眼就能看出变量、函数的用途，就可以少犯错误。同时合理的命名也能让别人一眼就能读懂代码的意图。

**面试小提示**

> 应聘者在写代码的时候，最好用完整的英文单词组合命名变量和函数，以便面试官能一眼读懂代码的意图。

## 代码的完整性

通常面试官会检查应聘者的代码是否完成了基本功能、输入边界值是否得到正确的输出、是否对各种不合规范的非法输入做出了合理的错误处理。

1. 从3个方面确保代码的完整性

   应聘者在写代码之前，首先要把可能的输入都想清楚，从而避免在程序中出现各种各样的质量漏洞。也就是说，在编码之前要考虑单元测试。如果能够设计全面的单元测试用例并在代码中体现出来，那么写出的代码自然也就是完整正确的。通常我们可以从功能测试、边界测试和负面测试3个方面设计测试用例，以确保代码的完整性。

   首先考虑的是普通的功能测试的测试用例。我们首先要保证写出的代码能够完成面试官要求的基本功能。比如面试题要求完成的功能是把字符串转换成整数，这里要把零、正数和负数都考虑进去。

   在考虑功能测试的时候，我们要尽量突破常规思维的限制。面试的时候我们经常受到惯性思维的限制，从而看不到更多的功能需求。比如面试题“打印从1到最大的n位数”，很多人觉得这道题很简单。最大的3位数是999、最大的4位数是9999，这些数字很容易就能算出来。但是最大的n位数都能用int型表示吗？超出int的范围我们可以考虑long long类型，超出long long能够表示的范围呢？是不是要求考虑任意大的数字？此时我们需要特殊的数据结构来表示数字，比如用字符串或者数组来表示大的数字，以确保不会溢出。

   其次需要考虑各种边界值的测试用例。很多时候我们的代码中都会有循环或者递归。如果我们的代码基于循环，那么结束循环的边界条件是否正确？如果基于递归，那么递归终止的边界值是否正确？

   最后还需要考虑各种可能的错误输入，也就是通常所说的负面测试的测试用例。我们写出的函数除了要顺利地完成要求的功能，当输入不符合要求的时候还能做出合理的错误处理。

   前面所说的都是要全面考虑当前需求对应的各种可能输入。在软件开发过程中，永远不变的就是需求会一直改变。如果我们在面试的时候写出的代码能够把将来需求可能的变化都考虑进去，在需求发生变化的时候能够尽量减少代码改动的风险，那么我们就向面试官展示了自己对程序可扩展性和可维护性的理解。

2. 3种错误处理的方法

   通常我们有3种方式把错误信息传递给函数的调用者。第一种方式是函数用返回值来告知调用者是否出错。微软为不同的非零返回值定义了不同的意义，调用者可以根据这些返回值判断出错的原因。这种方式最大的问题是使用不便，因为函数不能直接把计算结果通过返回值赋值给其他变量，同时也不能把这个函数计算的结果直接作为参数传递给其他函数。

   第二种方式是当错误发生时设置一个全局变量。此时我们可以在返回值中传递计算结果了。这种方式比第一种方法使用起来更加方便，因为调用者可以直接把返回值赋值给其他变量或者作为参数传递给其它函数。但这种方法有一个问题：调用者很容易忘记检查全局变量，因此在调用出错的时候忘记进行相应的错误处理，从而留下安全隐患。

   第三种方式是异常。当函数运行出错的时候，我们就抛出一个异常，还可以根据不同的出错原因定义不同的异常类型。因此，函数的调用者根据异常的类型就能知道出错的原因，从而做出相应的处理。另外我们能显示划分程序正常运行的代码块（try模块）和处理异常的代码块（catch模块），逻辑比较清晰。在抛出异常的时候，程序的执行的顺序会被打乱，对程序的性能有很大的影响。

   |          | 优点                                   | 缺点                                       |
   | -------- | :------------------------------------- | ------------------------------------------ |
   | 返回值   | 和系统API一致                          | 不能方便地使用计算结果                     |
   | 全局变量 | 能够方便地使用计算结果                 | 用户可能会忘记检查全局变量                 |
   | 异常     | 可以为不同的出错原因定义不同的异常类型 | 有些语言不支持异常，抛出异常时对性能有影响 |

### 面试题16：数值的整数次方

> 题目：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

- 自以为题目简单的解法

  指数没有考虑零和负数的情况，底数没有考虑为零的情况。

- 全面但不够高效的解法

  通过循环实现

- 即全面又搞笑的解法

  如果输入的指数exponent为32，则要执行32次乘法。但可以换一种思路考虑：我们的目标是求出一个数字的32次方，如果我们已经知道它的16次方，那么只要在16次方的基础上再平方一次就可以了。而16次方是8此方法的平方。以此类推，我们求32次方只需做5次乘法：先求平方，在平方的基础上求4次方，在4次方的基础上求8次方，在8次方的基础上求16次方，最后在16次方的基础上求32次方。求a的n次方的公式如下：
  $$
  a^n = \begin{cases}
  a^{n/2}\cdot a^{n/2} & n为偶数\\
  a^{(n-1)/2}\cdot a^{(n-1)/2}\cdot a & n为奇数
  \end{cases}
  $$

  并且通过使用右移运算符代替除法，使用位于运算符代替求余运算符来判断一个树是奇数还是偶数。位运算符比乘除法和求余运算符的效率高很多。

### 面试题17：打印从1到最大的n位数

> 题目：输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1,2,3一直到最大的3位数999。

- 跳进面试官陷阱

  ```c++
  void Print1ToMaxOfNDigits_1(int n)
  {
      int number = 1;
      int i = 0;
      while(i++ < n)
          number *= 10;
      
      for(i = 1; i < number; ++i)
          printf("%d\t", i);
  }
  ```

  当输入的n很大的时候，我们求最大的n位数是不是用整形（int）或者长整形（long long）都会溢出？

- 在字符串上模拟数字加法的解法，绕过陷阱才能拿到Offer

  最常用也是最容易的方法是用字符串或者数组表达大数。

  在用字符串表示数字的时候，最直观的方法就是字符串里每个字符都是'0'\~'9'之间的某一个字符，用来表示数字中的一位。因为数字最大是n位的，因此我们需要一个长度为n+1的字符串（字符串中最后一位是结束符号'\0'）。当实际数字不够n位的时候，在字符串的前半部分补0。

  首先把字符串中的每一个数字都初始化为'0'，然后每一次为字符串表示的数字加1，再打印出来。因此，我们只需要做两件事：一是在字符串表达的数字上模拟加法；二是把字符串表达的数字打印出来。

  ```c++
  void Print1ToMaxOfNDigits(int n)
  {
      if(n <= 0)
          return;
      char* number = new char[n+1];
      for(int i=0; i<n; i++)
      {
          number[i] = '0';
      }
      number[n] = '\0';
      
      while(!Increment(number))
      {
          PrintNumber(number);
      }
      delete []number;
  }
  ```

  

  我们需要直到什么时候停止在number上增加1，即什么时候到了最大的n位数“999…99”（n个9）。一个简单的方法是在每次递增之后，都调用库函数strcmp比较表示数字的字符串和最大的n位数“999…99”，如果相等则表示已经到达了最大的n位数并终止递增。虽然调用strcmp很简单，但对于长度为n的字符串，它的时间复杂度为O(n)。

  我们注意到只有对“999…99”加1的时候，才会在第一个字符（下标为0）的基础上产生进位，而其他所有情况都不会在第一个字符上产生进位。因此，当我们发现在加1时第一个字符产生了进位，则已经是最大的n位数，此时Increment返回true，因此函数Print1ToMaxOfNDigits中的while循环终止。如何在每一次增加1之后快速判断是不是到了最大的n位数是本题的一个小陷阱。

  ```c++
  bool Increment(char* number)
  {
      booll is Overflow = false;
      int nTakeOver = 0;
      int nLength = strlen(number);
      for(int i=nLength-1; i>=0; i--)
      {
          int nSum = number[i]-'0'+nTakeOver;
          if(i == nLength - 1)
              nSum++;
          if(nSum >= 10)
          {
              if(i == 0)
                  isOverflow = true;
              else
              {
                  nSum -= 10;
                  nTakeOver = 1;
                  number[i] = '0' + nSum;
              }
          }
          else
          {
              number[i] = '0' + nSum;
              break;
          }
      }
  }
  void PrintNumber(char* number)
  {
      bool isBeginning0 = true;
      int nLength = strlen(number);
      
      for(int i=0; i<nLength; ++i)
      {
          if(isBeginning0 && number[i]!='0')
              isBeginning0 = false;
          
          if(!isBeginning0)
          {
              printf("%c", number[i]);
          }
      }
  }
  ```

- 把问题转换为数字排列的解法，递归让代码更简洁

  上述思路虽然比较直观，但由于模拟了整数的加法，代码有点长。要在面试短短几十分钟里完整、正确地写出这么长的代码，对很多应聘者而言不是一件容易的事情。可以换一种思路考虑这个问题。如果我们在数字前面补0，就会发现n位所有十进制数其实就是n个从0到9的全排列。

  ```c++
  void Print1ToMaxOfNDigits_2(int n)
  {
      if (n <= 0)
          return;
  
      char* number = new char[n + 1];
      number[n] = '\0';
  
      for (int i = 0; i < 10; ++i)
      {
          number[0] = i + '0';
          Print1ToMaxOfNDigitsRecursively(number, n, 0);
      }
  
      delete[] number;
  }
  
  void Print1ToMaxOfNDigitsRecursively(char* number, int length, int index)
  {
      if (index == length - 1)
      {
          PrintNumber(number);
          return;
      }
  
      for (int i = 0; i < 10; ++i)
      {
          number[index + 1] = i + '0';
          Print1ToMaxOfNDigitsRecursively(number, length, index + 1);
      }
  }
  ```

**本题考点**

- 考查应聘者解决大数问题的能力。面试官出这道题目的时候，他期望应聘者能意识到这是一个大数问题，同时还期待应聘者能定义合适的数据表示方式来解决大数问题。
- 如果应聘者采用第一种思路，即在数字上加1逐个打印的思路，则面试官会关注他判断是否已经到了最大的n位数时采用的方法。应聘者要注意到不同方法的时间效率相差很大。
- 如果应聘者采用第二种思路，则面试官还将考查他用递归方法解决问题的能力。
- 面试官还将关注应聘者打印数字时会不会打印出位于数字前面的0。这里能体现出应聘者在设计开发软件时是不是考虑用户的使用习惯。通常我们的软件设计和开发需要符合大部分用户的人机交互习惯。

**本题扩展**

在前面的代码中，我们使用一个char型字符表示十进制数字的一位。8bit的char型字符最多能表示256个字符，而十进制数字只有0~9的10个数字。因此，用char型字符来表示十进制数字并没有充分利用内存，有一些浪费。有没有更高效的方式来表示大数？

思考：使用数组加int类型，int有四个字节，可以表示为9位的最大数字999999999，所以可以将其合并成一个大数，而且计算速度更快。

**相关题目**

定义一个函数，在该函数中可以实现任意两个整数的加法。由于没有限定输入两个数的大小范围，我们也要把它当做大数问题来处理。在前面的代码的第一种思路中，实现了在字符串表示的数字上加1的功能，我们可以参考这种思路实现两个数字的相加功能。另外还有一个需要注意的问题：如果输入的数字中有负数，那么我们应该怎么处理？

**面试小提示**

> 如果面试题是关于n位的整数并且没有限定n的取值范围，或者输入任意大小的整数，那么这道题目很可能是需要考虑大数问题的。字符串是一种简单、有效地表示大数的方法。

### 面试题18：删除链表的节点

> 题目1：在O(1)时间内删除链表节点
>
> 给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。链表节点与函数定义如下：

```c++
struct ListNode
{
    int			m_nVal;
    ListNode*	m_pNext;
    ListNode(int val):m_nVal(val),m_pNext(nullptr){}
}

void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted);
```

不一定需要得到被删除的节点的前一个节点。我们可以很方便地得到要删除的节点的下一个节点。如果我们把下一个节点的内容复制到需要删除的节点上覆盖原有的内容，再把下一个节点删除，从而实现把当前需要删除的节点删除了。

上述思路，有一个问题就是当要删除的节点位于链表的尾部则需要特殊处理。并且如果链表中只有一个节点，而我们要删除链表的头结点（也是未节点），那么，在删除节点之后，还需要把链表的头结点设置为nullptr。

上述代码仍然不是完美的代码，因为它基于一个假设：要删除的节点的确在链表中。我们需要O(n)的时间才能判断链表中是否包含一个节点。受到O(1)时间的限制，我们不得不把确保节点在链表中的责任退给了函数DeleteNode的调用者。

**测试用例**

- 功能测试（从有多个节点的链表的中间删除一个节点；从有多个节点的链表中删除头结点；从有多个节点的链表中删除尾节点；从只有一个节点的链表中删除唯一的节点）。
- 特殊输入测试（指向链表头结点的为nullptr指针；指向要删除节点为nullptr指针）。

**本题考点**

- 考查应聘者的创新思维能力。这道题要求应聘者打破常规的思维模式。当我们想删除一个节点时，并不一定要删除这个节点本身。可以先把下一个节点的内容复制出来覆盖被删除节点的内容，然后拔下一个节点删除。
- 考查应聘者思维的全面性。即使应聘者想到删除下一个节点这个办法，也未必能通过这轮面试。应聘者要全面考虑删除的节点位于链表的尾部及输入的链表只有一个节点这些特殊情况。

>题目二：删除链表中重复的节点。
>
>在一个排序的链表中，如何删除重复的节点？

**测试用例**

- 功能测试（重复的节点位于链表的头部/中间/尾部；链表中没有重复节点）。
- 特殊输入测试（指向链表头结点的为nullptr指针；链表中所有节点都是重复的）。

**本题考点**

- 考查应聘者思维的全面性。应聘者要全面考虑重复节点所处的位置，以及删除重复节点之后的结果。

### 面试题19：正则表达式匹配（<font color=red>失败</font>）

> 题目：请实现一个函数用来匹配包含'.'和'\*'的正则表达式。模式中的字符'.'表示任意一个字符，而'\*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 "aaa" 与模式 "a.a" 和 "ab\*ac\*a" 匹配，但与 "aa.a" 和 "ab\*a" 均不匹配。

当模式中的第二个字符是'\*'时，问题要复杂一些，因为可能有多种不同的匹配方式。一种选择是在模式上向后移动两个字符。这相当于'\*'和它前面的字符被忽略掉了，因为'\*'可以匹配字符串中的0个字符。如果模式中的第一个字符和字符串中的第一个字符相匹配，则在字符串上向后移动一个字符，而在模式上有两种选择：可以在模式上向后移动两个字符，也可以保持模式不变。

**测试用例：**

- 功能测试（模式字符串里包含普通字符、'.'、'*'：模式字符串和输入字符串匹配/不匹配）。
- 特殊输入测试（字符串中有'.*'；输入字符串和模式字符串是nullptr、空字符串）。

**本题考点：**

- 考查应聘者对状态机的理解

### 面试题20：表示数值的字符串（<font color=red>失败</font>）

> 题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e3"、"-123"、"3.1416"及"-1E-16"都表示数值，但 "12e" 、 "1a3.14" 、 "1.2.3" 、 "+-5" 及 "12e+5.4"都不是。

表示数字的字符串遵循模式A\[.\[B\]\]\[e|EC\]或者.B\[e|EC\]，其中A为数值的整数部分，B紧跟小数点为数值的小数部分，C紧跟着'e'或者'E'为数值的指数部分。在小数里可能没有数值的整数部分。因此A部分不是必需的。如果一个数没有整数部分，那么它的小数部分不能为空。

上述A和C都可以以'+'或者'-'开头的0\~9的数位串；B也是0\~9的数位串，但前面不能有正负号。

判断一个字符串是否符合上述模式时，首先尽可能多地扫描0~9的数位（有可能在起始处有'+'或者'-'），也就是前面模式中表示数值整数的A部分。如果遇到小数点'.'，则开始扫描表示数值小数部分的B部分。如果遇到'e'或者'E'，则开始扫描表示数值指数的C部分。

**测试用例：**

- 功能测试（正数或者负数；包含或者不包含整数部分的数值；包含或者不包含小数部分的数值；包含或者不包含指数部分的数值；各种不能表达有效数值的字符串）。

- 特殊输入测试（输入字符串和模式字符串是nullptr、空字符串）。

### 面试题21：调整数组顺序使奇数位于偶数前面

> 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

如果不考虑时间复杂度，则最简单的思路就是从头扫描这个数组，每碰到一个偶数，拿出这个数字，并把位于这个数字后面的所有数字往前挪动一位。挪完之后在数组的末尾空位，这时把该偶数放入这个空位。由于每碰到一个偶数就需要移动O(n)个数字，因此总的时间复杂度是$O(n^2)$。

- 只完成基本功能的解法

  我们在扫描这个数组的时候，如果发现有偶数出现在奇数的前面，则交换它们的顺序，交换之后就符合要求了。

  因此，我们可以维护两个指针；第一个指针初始化时指向数组的第一个数字，它只向后移动；第二个指针初始化时指向数组的最后一个数字，它只向前移动。在两个指针相遇之前，第一个指针总是位于第二个指针的前面。如果第一个指针指向的数字是偶数，并且第二个指针指向的数字是奇数，则交换这两个数字。

- 考虑可扩展的解法

  面试官：如果把题目改成把数组中的数按照大小分为两部分，所有负数都在非负数的前面，该怎么做？

  有时候面试官期待我们提供的不仅仅是解决一个问题的办法，而是解决一系列同类型问题的通用办法。这就是面试官在考查我们对扩展性的理解，即希望我们能给出一种模式，在这种模式下能很方便地把已有的解决方案扩展到同类型的问题上去。

  回到面试官提出的两个问题上。要解决这两个新的问题，其实只需要修改函数ReorderOddEven中的两处判断的标准，而大的逻辑框架完全不需要改动。因此我们可以把这个逻辑框架抽象出来，而把判断的标准变成一个函数指针，也就是用一个单独的函数来判断数字是不是符合标准。这样我们就可以将整个函数解耦成两部分：一是判断数字应该在数组前半部分还是后半部分的标准；二是拆分数组的操作。

  如果把问题改成将数组中的负数移到非负数的前面，或者把能被3整除的数移到不能被3整除的数的前面，都只需定义新的函数来确定分组的标准，而函数Recorder不需要进行任何改动。也就是说，解耦的好处就是提高了代码的重用性，为功能扩展提供了遍历。

## 代码的鲁棒性

容错性是鲁棒性的一个重要体现。不鲁棒的软件在发生异常时间的时候，比如用户输入错误的用户名、试图打开的文件不存在或者网络不能连接，就会出现不可预见的诡异行为，或者干脆整个软件崩溃。

提高代码的鲁棒性的有效途径是进行防御性编程。防御性编程是一种编程习惯，是指预见在什么地方可能会出现问题，并为这些可能出现的问题制定处理方式。比如，当试图打开文件时发现文件不存在，可以提示用户检查文件名和路径；当服务器连接不上时，可以试图连接备用服务器等。这样，当异常情况发生时，软件的行为也尽在我们的掌握之中，而不至于出现不可预见的事情。

在面试时，最简单也最实用的防御性编程就是在函数入后添加代码以验证用户输入是否符合要求。我们需要格外关注这些函数的输入参数，如果输入的是一个指针，那么指针为空怎么办？如果输入的是一个字符串，那么字符串的内容为空怎么办？等等。

并不是所有与鲁棒性相关的问题都只是检查输入的参数这么简单。我们看到问题的时候，要多问几个“如果不……那么……”这样的问题。

### 面试题22：链表中倒数第k个节点

> 题目：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的未节点是倒数第1个节点。

其中隐含着一个条件，即链表中节点的个数大于k。这时就需要注意但如果链表中节点的数目不是大于k个，那么代码会出现什么问题？

由于是单向链表，所以不能从尾节点开始遍历这个链表。那么假设整个链表有n个节点，则倒数第k个节点就是从头结点开始的第n-k+1个节点。如果我们能够得到链表中节点的个数n，那么只要从头结点开始往后走n-k+1步就可以了。如何得到节点数n？只需要从头结点开始遍历链表，每经过一个节点，计数器加1就行了。

也就是说我们需要遍历链表两次，第一次统计出链表中节点的个数，第二次就能找到倒数第k个节点。但是有没有只用遍历链表1次的方法。

为了实现只遍历链表一次就能找到倒数第k个节点，我们可以定义连个指针。第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当地一个（走在前面的）指针到达链表的未节点时，第二个（走在后面的）指针正好指向倒数第k个节点。

**面试小提示**

> 面试过程中写代码要特别注意鲁棒性。如果写出的代码存在多处崩溃的风险，那么我们很有可能和Offer失之交臂。

**相关题目：**

求链表的中间节点。如果链表中的节点总数为奇数，则返回中间节点；如果节点总数是偶数，则返回中间两个节点的任意一个。为了解决这个问题，我们也可以定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。当走的快的指针走到链表的末尾时，走的慢的指针正好在链表的中间。

**举一反三:**

> 当我们用一个指针遍历链表不能解决问题的时候，可以尝试用两个指针来遍历链表。可以让其中一个指针遍历的速度快一些（比如一次再链表走两步），或者让它先在链表上走若干步。

### 面试题23：链表中环的入口节点

> 题目：如果一个链表中包含环，如何找出环的入口节点？

第一步是如何确定一个链表中包含环。和前面的问题一样，定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上走得慢的指针，那么链表就包含环；如果走得快的指针走到了链表的末尾都没有追上第一个指针，那么链表就不包含环。

第二步是如何找到环的入口。先定义两个指针P~1~和P~2~指向链表的头结点。如果链表中的环有n个节点，则指针P~1~先在链表上向前移动n步，然后两个指针以相同的速度向前移动。当第二个指针指向环的入口节点时，第一个指针已经围绕着环走了一圈，又回到了入口节点。（<font color=red>那么怎么知道n为多少呢？</font>）

剩下的问题是如何得到环中节点的数目。我们在前面判断一个链表里是否有环时用到了一快一慢两个指针。如果两个指针相遇，则表明链表中存在环。两个指针相遇的节点一定在环中。可以从这个节点出发，一边继续向前移动一边计数，当再次回到这个节点时，就可以得到环中节点数了。

**LeetCode:**

第二步稍有调整：

![image](https://pic.leetcode-cn.com/99987d4e679fdfbcfd206a4429d9b076b46ad09bd2670f886703fb35ef130635-image.png)
$$
\begin{aligned}
2(F + a) & = F + N(a+b) + a \\
2F + 2a & = F + 2a + b + (N-1)(a+b) \\
F & = b + (N-1)(a+b)
\end{aligned}
$$


因为F=b+(N-1)(a+b)，指针从h点出发和从链表的头出发，以相同的速度遍历，最后会在环的入口处相遇。

### 面试题24：反转链表

> 题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。

在面试的时候我们不要急于动手写代码，而是一开始仔细分析和设计，这将会个给面试官留下很好的印象。与其很快写出一段漏洞百出的代码，倒不如仔细分析再写出鲁棒的代码。

编写的代码容易出现以下3种问题：

- 输入的链表头指针为nullptr或者整个链表只有一个节点时，程序容易崩溃。
- 反转后的链表出现断裂
- 返回的反转之后的头结点不是原始链表的尾结点

应聘者在写出代码之前，就准备好测试用例检查测试。如果面试以手写代码的方式，那也要在心里默默运行代码进行单元测试。只有确保代码通过测试之后，再提交给面试官。

**本题扩展**

用递归实现同样的反转链表的功能

### 面试题25：合并两个排序的链表

> 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

编程中最容易犯两种错误：一是在写代码之前没有想清楚合并的过程，最终合并出来的链表要么中间断开了、要么就没有做到递增排序；二是代码在鲁棒性方面存在问题，程序一旦有特殊的输入（如空链表）就会崩溃。

首先分析合并两个链表的过程。我们的分析从合并两个链表的头结点开始。如果链表1的头结点的值小于链表2的头结点的值，因此链表1的头结点将是合并后链表的头结点。

我们继续合并两个链表中剩余的节点。在两个链表中剩下的节点依然是排序的，因此合并这两个链表的步骤和前面的步骤是一样的。

当我们得到两个链表中值较小的头结点并把它链接到已经合并的链表之后，两个链表剩余的节点依然是排序的，因此合并的步骤和之前的步骤是一样的。这就是典型的递归过程，我们可以定义递归函数完成这一合并过程。

接下来我们来解决鲁棒性的问题。每当代码试图访问空指针指向的内存时程序就会崩溃，从而导致鲁棒性问题。在本题中一旦输入空的链表就会引入空的指针，因此我们要对空链表单独处理。当地一个链表是空链表，也就是他的头结点是一个空指针时，那么把它和第二个链表合并，显然合并的结果就是第二个链表。同样，当输入的第二个链表的头结点是空指针的时候，我们把它和第二个链表合并得到的结果就是第一个链表。如果两个链表都是空链表，则合并的结果就是一个空链表。

**本题考点**

- 考查应聘者能不能写出鲁邦的代码。由于有大量指针操作，应聘者如果不小心就会在代码中遗留很多与鲁棒性相关的隐患。建议应聘者在写代码之前全面分析哪些情况会引入空指针。

### 面试题26：树的子结构

> 题目：输入两颗二叉树A和B，判断B是不是A的子结构。

要查找树A中是否存在和树B结构一样的子树，我们可以分成两部：第一步，在树A中找到和树B的根节点的根节点的值一样的节点R：第二步，判断树A中以R为根节点的子树是不是包含和B一样的结构。

第一步在树A中查找与根节点一样的节点，这实际上就是树的遍历。对二叉树这种数据结构可以用递归的方法遍历，也可以用循环的方法去遍历，也可以用深度优先算法和广度优先算法。由于递归的代码实现比较简洁，面试时如果没有特别要求，那么通常采用递归的方式。

在面试的时候，我们一定要注意边界条件的检查，即检查空指针。如果没有检查并进行相应的处理，则程序非常容易崩溃。

第二步是判断树A中以R为根节点的子树是不是和树B具有相同的结构。同样，我们也可以用递归的思路来考虑：如果节点R的值和树B的根节点不相同，则以R为根节点的子树和树B肯定不具有相同的节点；如果它们的值相同，则递归地判断它们各自的左右节点的值是不是相同。递归的终止条件是我们到达了树A或者树B的叶子节点。

我们注意到上述代码有多处判断一个指针是不是nullptr，这样做是为了避免试图访问空指针而造成程序崩溃，同时也设置了递归调用的退出条件。在写遍历树的代码的时候一定要高度警惕，在每一处需要访问地址的时候都要问自己这个地址有没有可能是nullptr、如果是nullptr则该怎么处理。

**面试小提示**

> 与二叉树相关的代码有大量的指针操作，在每次使用指针的时候，我们都要问自己这个指针有没有可能是nullptr，如果是nullptr则该怎么处理。

为了确保自己所写的代码完整、正确，在写出代码之后，应聘者至少要用几个测试用例来检验自己的程序：树A和树B的头结点有一个或者两个都是空指针；在树A和树B的节点中含有分叉。

一个细节值得我们注意：本题中节点的值的类型为double。在判断两个节点的值是不是相等时，不能使用==，这是因为在计算机内表示小数时（包括float和double型小数）都有误差。判断两个小数是否相等，只能判断它们之差的绝对值是不是在一个很小的范围内。如果两个数相差很小，就可以认为它们相等。

**面试小提示**

> 由于计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，如小于0.0000001，既可以认为它们相等。

## 总结