[TOC]
# 面试所需的基础知识
## 编程语言
**sizeof的概念**  
问题：定义一个空的类型，里面没有任何成员变量和成员函数。对该类型求sizeof，得到的结果是多少？  
答案：1  
问题：为什么不是0？  
答案：空类型的实例中不包含任何信息，本来求sizeof应该是0，但是当我们声明该类型的实例的时候，它必须在内存中占用一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。在VS中，每个空类型占用1字节的空间。  
问题：如果在该类型中添加一个构造函数和析构函数，再对该类型求sizeof，得到的结果又是多少？  
答案：和之前的一样，还是1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数而在实例内添加任何额外的信息。  
问题：如果把析构函数标记为虚函数呢？  
答案：C++的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，一个指针占4字节的空间，因此求sizeof得到4；如果是64位的机器，则一个指针占8字节的空间，因此求sizeof得到8。

**复制构造函数**  
C++的标准不允许复制构造函数传值参数，应该吧传值参数改成常量引用。

C++推荐书籍：  
- Effective C++
- C++ Primer
- 深度探索 C++对象模型
- C++程序设计语言 

### 面试题1：赋值运算符函数  
>题目：如下类型CMyString的声明，请为该类型添加赋值运算符函数
```c++
class CMyString
{
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    ~CMyString(void);
private:
    char* m_pData;
};
```
**注意事项：**

- 是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的应用。只有返回一个引用，才可以允许连续赋值
- 是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次赋值构造函数。而把参数声明为引用可以提高代码的效率。同时，在赋值运算符内不会改变传入的实例的状态，因此传入的引用参数加上const关键字。
- 是否释放实例自身已有的内存（==有什么地方是需要释放的呢？==）。避免出现内存泄漏。
- 判断传入的参数和当前的实例（*this）是不是同一个实例。如果是同一个，则不进行赋值操作，直接返回。如果实现不判断就进行赋值，那么在释放实例自身内存的时候就会导致严重的问题。

#### 经典解法

```c++
CMyString& CMyString::operator = (const CMyString& str)
{
    if(this == &str)
        return *this;

    // 如果m_pData是一个空指针
    // 那么delete会出现问题
    // 所以可以在delete之前进行判断
    delete []m_pData;
    m_pData = nullptr;
    // 加一的原因是因为字符串最后有一个空字符吗
    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pData, str.m_pData);

    return *this;
}
```
#### 考虑异常安全性的解法，高级程序员必备
前面的函数中，如果m_pData是空指针，当使用delete释放m_pData的内存时，容易导致程序崩溃。一旦在赋值运算符函数内部抛出一个异常，CMyString的实例不再保持有效的状态，这就违背了异常安全性原则。
要想在赋值运算符函数中实现异常安全性，一般有两种方法：一种简单的方法是先用new分配新内容，再用delete释放已有的内容（为什么不是在delete之前判断该指针是否为空呢？）。另一种方法是先创建一个临时实例，再交换临时实例和原来的实例。

```c++
CMyString& CMyString::operator=(const CMyString& str)
{
    if(this!=&str)
    {
        CMyString strTemp(str);
        
        // 交换
        char* pTemp = strTemp.m_pData;
        strTemp.m_pData = m_pData;
        m_pData = pTemp;
    }
    return *this
}
```
由于strTemp是一个局部变量，但程序运行到if的外面时也就出了该变量的作用域，就会自动调用strTemp的析构函数，把strTemp.m\_pData所指向的内存释放掉。由于strTemp.m\_pData指向的内存就是实例之前m_pData的内存，这就相当于自动调用析构函数释放实例的内存。

个人理解：  
首先利用构造函数的new分配内存，其次利用析构函数的delete来释放内存，这样更加匹配，如果单纯在一个函数中使用delete是十分危险的。而且如果使用new分配内存时出现内存不足的情况，也不会修改需要赋值的实例的状态，因为这个分配内存的操作作是在临时对象中进行的，这样就保证了异常安全性。

测试用例：
- 把一个CMyString的实例赋值个另一个实例。
- 把一个CMyString的实例赋值给它自己。
- 连续赋值。

本题考点：
- 考查应聘者对C++基础语法的理解，如运算符函数、常量引用等。
- 考查应聘者对内存泄漏的理解。
- 对于高级C++程序员，面试官还将考查应聘者对代码异常安全性的理解。

**struct和class的异同**  
问题：在C\+\+中可以用struct和class来定义类型。这两种类型有什么区别？  
答案：如果没有标明成员函数或者成员变量的访问权限级别。那么在struct中默认的是public，而在class中默认的是private。  
问题：那在C#中呢？  
答案：C#和C\+\+ 不一样。在C#中如果没有标明成员函数或者成员变量的访问权限级别，则在struct和class中都是private的。struct和class的区别是struct定义的是值类型，值类型的实例在栈上分配内存；而class定义的是引用类型，引用类型的实例是在堆上分配内存的。

c#的Finalizer方法和c\+\+析构函数看起来一样，但C\+\+析构函数的调用时机是确定的；而C#的Finalizer是在运行时(CLR)进行垃圾回收时才会被调用的，它的调用时机是由运行时决定的，因此对程序员来说是不确定的。另外，在C#中可以为类型定义一个特殊的构造函数：静态构造函数。这个函数的特点是在类型第一次被使用之前由运行时自动调用的，而且保证只调用一次。
```c++
class A
{
    public A(string text)
    {
        Console.WriteLine(text);
    }
}
class B
{
    static A a1 = new A("a1");
    A a2 = new A("a2");
    
    static B()
    {
        a1 = new A("a3");
    }
    
    public B()
    {
        a2 = new A("a4");
    }
}

class Program
{
    static void Main(string[] args)
    {
        B b = new B();
    }
}
```
在调用类型B的代码之前先执行B的静态构造函数。静态构造函数先初始化类型的静态变量，在执行函数体内的语句。因此先打印a1再打印a3。接下来执行B b = new B()，即调用B的普通构造函数。构造函数先初始化成员变量，再执行函数体内的语句，因此先打印出a2、a4。

C#特有功能：反射、应用程序域。

C#相关的书籍：  
- Professional C#
- CLR Via C#

### 面试题2：实现Singleton模式
>题目：设计一个类，我们只能生成该类的一个实例。

## 数据结构
大多数面试题都是围绕着数组、字符串、链表、数、栈及队列这几种常见的数据结构展开的。

数组和字符串是两种最基本的数据结构。链表和树是面试中出现频率最高的数据结构。由于操作链表和树是面试中出现频率最高的数据结构。由于操作链表和树需要操作大量的指针，所以在解决相关问题的时候一定要留意代码的鲁棒性。栈是一个与递归紧密相关的数据结构，同样队列也与广度优先遍历算法紧密相关。
### 数组
可以根据下标在O(1)时间读/写任何元素。

用数组可以实现简单的哈希表：把数组的下标设为哈希表的键值(Key)，而把数组中的每一个数字设为哈希表的值(Value)，这样每一个下标及数组中该下标对应的数字就组成了一个“键值-值”的配对。

STL的vector每次扩充容量时，新的容量都是前一次的两倍。这对时间性能有负面影响，因此使用动态数组时要尽量减少改变数组容量大小的次数。

当我们声明一个数组时，其数组的名字也是一个指针，该指针指向数组的第一个元素。值得注意的是，C/C++没有记录数组的大小，因此在使用指针访问数组中的元素时，程序员要确保没有超出数组的边界。
```c++
int Getsize(int data[])
{
    return sizeof(data);
}

int _tmain(int argc, _TCHAR* argv[])
{
    int data1[] = {1,2,3,4,5};
    int size1 = sizeof(data1);
    
    int* data2 = data1;
    int size2 = sizeof(data2);
    
    int size3 = GetSize(data1);
    
    printf("%d,%d,%d",size1,size2,size3);
}
```
答案是“20,4,4”。data1是一个数组，sizeof(data1)是求数组的大小。这个数组包含5个整数，每个整数占4个字节，因此共占用20个字节。data2声明为指针，尽管它指向了数组data1的第一个数字，但它的本质仍然是一个指针。对于32位系统，对任意指针求sizeof，得到的结果都是4.在C/C++ 中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针。因此，尽管函数GetSize的参数data被声明为数组，但它会退化为指针，所以size3的结果仍然为4

#### 面试题3：数组中重复的数字
>题目一：找出数组中重复的数字。
>在一个长度位n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但是不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

解决方法：  
- 数组排序。排序一个长度位n的数组需要O(nlogn)的时间。
- 哈希表。时间复杂度是O(n)，但空间复杂度位O(n)。
- 通过分析可以发现数组中的数字都在0~n-1的范围内。如果这个数组中没有重复的数字。那么当数组排序之后数字i将出现在下标为i的位置。

```c++
/**
 * @brief duplicate     查找数组中重复的元素
 * @param numbers       数组
 * @param length        数组长度
 * @param duplication   记录重复的数字
 * @return
 */
bool duplicate(int numbers[], int length, int* duplication)
{
    // 确保数组不为空
    if(numbers == nullptr || length <= 0)
        return false;

    // 确保数组中的元素都在0~n-1的范围内
    for(int i = 0; i < length; ++i)
    {
        if(numbers[i] < 0 || numbers[i] > length - 1)
            return false;
    }

    // 遍历数组
    for(int i = 0; i < length; ++i)
    {
        while(numbers[i] != i)
        {
            // 观察当前元素是否与以当前元素为索引的数组元素相同，如果相同，则为重复元素
            if(numbers[i] == numbers[numbers[i]])
            {
                *duplication = numbers[i];
                return true;
            }

            // 交换numbers[i]和numbers[numbers[i]]
            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }

    return false;
}
```
尽管代码中有一个两重循环，但每个数字最多只要交换两次就能找到自己的位置，因此中的时间复杂度是O(n)。另外，所有的操作都是在输入数组上进行的，不需要额外分配内存，因此空间复杂度位O(1)。

测试用例：  
- 长度为n的数组里包含一个或多个重复的数字；
- 数组中不包含重复的数字；
- 无效输入测试用例。

>题目二：不修改数组找出重复的数字。
>在一个长度长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。

方法一：由于题目要求不能修改输入的数组，我们可以创建一个长度位n+1的辅助数组，然后逐一把原数组的每个数字复制到辅助数组。如果原数组中被复制的数字是m，则把它复制到辅助数组中下标位m的位置。该方案需要O(n)的辅助空间。

方法二：把1\~n的数字从中间的数字m分成两部分，前面一半为1\~m，后面一半位m+1\~n。如果1\~m的数字的个数超过m，那么这一半的区间里一定包含重复的数字；否则，另一半m+1\~n的区间里一定包含重复的数字。然后可以一直把包含重复数字的区间一分为2，直到找到一个重复的数字。
```c++
int countRange(const int* numbers, int length, int start, int end);

int getDuplication(const int* numbers, int length)
{
    if(numbers == nullptr || length <= 0)
        return -1;

    // 索引
    int start = 1;
    int end = length - 1;
    while(end >= start)
    {
        // 左移相当于除2
        // 为什么不写成(end + start) >> 1，可能是如何是和，当end和start都很大的时候容易造成溢出
        int middle = ((end - start) >> 1) + start;
        // 对在start和middle范围内的数据统计个数。
        int count = countRange(numbers, length, start, middle);
        //
        if(end == start)
        {
            if(count > 1)
                return start;
            else
                break;
        }

        // 如果计数超过该范围的大小，那么则说明重复的元素在该范围内
        if(count > (middle - start + 1))
            end = middle;
        else
            start = middle + 1;
    }
    return -1;
}

/**
 * @brief countRange
 * @param numbers       int []      数组
 * @param length        int         数组长度
 * @param start         int         起始索引
 * @param end           int         终止索引
 * @return
 */
int countRange(const int* numbers, int length, int start, int end)
{
    if(numbers == nullptr)
        return 0;

    int count = 0;
    // 对所有的元素进行遍历
    for(int i = 0; i < length; i++)
        if(numbers[i] >= start && numbers[i] <= end)
            ++count;
    return count;
}
```
这是一种**二分查找**的方法，如果输入长度为n的数组，那么函数countRange将被调用O(logn)次，每次需要O(n)的时间，因此总的时间复杂度位O(nlogn)，空间复杂度位O(1)。

根据不同的功能要求和性能要求，使用不同的算法，所以需要在面试中和面试官多交流。

功能要求：  
找出任意一个重复的数字、找出所有重复的数字等。  
性能要求：  
时间效率优先、空间效率优先等。

#### 面试题4：二维数组中的查找
>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样一个二维数组和一个整数，判断数组中是否含有该整数。

在分析这个问题时，可以将二维数组画成矩形，然后从数组中选取一个数字，分几种情况来分析查找的过程。

可以知道有三种情况。首先是当数组中选取的数字刚好和要查找的数字相等时，就结束查找的过程。其次是如果选取的数字小于要查找的数字，那么根据数组排序的规则，要查找的数字应该在当前选取位置的右边或者下边。最后是如果选取的数字大于要查找的数字，那么要查找的数字应该在当前选取位置的上边或者左边。

首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。

将二维数组指针强制类型转换成一维数组指针，其实就是将二维数组按行拼接成一维数组。

```c++
bool Find(int* matrix, int rows, int columns, int number)
{
    bool found = false;

    if(matrix != nullptr && rows > 0 && columns > 0)
    {
        int row = 0;
        int column = columns - 1;
        while(row < rows && column >=0)
        {
            // 以列为主
            if(matrix[row * columns + column] == number)
            {
                found = true;
                break;
            }
            else if(matrix[row * columns + column] > number)
                -- column;
            else
                ++ row;
        }
    }

    return found;
}
```

**本题考点**

- 考查二维数组的理解及编程能力。二维数组在内存中占据连续的空间。在内存中从上到下存储各行元素，在同一行中按照从左到右的顺序存储。因此可以根据行和列计算出相对数组首地址的偏移量，从而找到对应的元素。
- 考察分析问题的能力。当发现问题比较复杂时，能不能通过具体的例子找出其中的规律，是能否解决这个问题的关键所在。这个问题只要从一个具体的二维数组的右上角开始分析，就能找到查找的规律。

### 字符串

C/C++中每个字符串都以字符 \'\0\'作为结尾，这样可以很方便地找到字符串的末尾。

为了节省内存，C/C++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。但是用常量内存初始化数组，情况却是不同的。
```c++
#include <iostream>

using namespace std;

int main()
{
    char str1[] = "hello world";
    char str2[] = "hello world";

    // 这种写法在c++11中并不支持
    const char* str3 = "hello world";
    const char* str4 = "hello world";

    // str1和str2的地址是不同的，但是str3和str3的地址是相同的。
    cout << (void*)str1 << endl
         << (void*)str2 << endl
         << (void*)str3 << endl
         << (void*)str4 << endl;
}
```
#### 面试题5：替换空格
>题目：请实现一个函数，把字符串中的每个空格都替换成"%20"。
在网络编程中，如果URL参数中含有特殊字符，如空格，'#'等，则可能导致服务器端无法获得正确的参数值。我们需要将这些特殊符号转换成服务器可以识别的字符。转换的规则是在'%'后面添加ASCII码的两位十六进制的表示。

如果是在原来的字符串上进行替换，就有可能覆盖修改在该字符串后面的内存。如果是创建新的字符串并在新的字符串上进行替换，那么就需要分配做够多的内存。由于有两种不同的解决方案，就需要向面试官问清楚，明确他的需求。

- 时间复杂度为$O(n^2)$的解法，不足以拿到Offer
  最直观的做法是从头到尾扫描字符串，每次碰到空格字符的时候进行替换。由于是把1个字符替换成3个字符，我们必须把空格后面所有的字符都向后移2个字节。
  假设字符串的长度是n。对每个空格字符，需要移动后面O(n)个字符，因此对于含有O(n)个空格字符的字符串而言，总的时间效率是$O(n^2)$。（<font color=#FF0000>不是很理解</font>）
- 时间复杂度为$O(n^2)$的解法，搞定Offer就靠它了
  可以先遍历一次字符串，统计字符串中空格的总数，并由此计算出替换之后的字符串的总长度。然后从字符串的末尾开始复制和替换。
  使用该方法，所有的字符都只复制一次，因此这个算法的时间效率位O(n)。比第一种方法要快。

**测试用例**

- 输入的字符串包含空格（空格位于字符串的最前面；空格位于字符串的最后面；空格位于字符串的中间；字符串中有连续多个空格）
- 输入的字符串中有连续多个空格
- 特殊输入测试（字符串是一个nullptr指针，字符串是一个空字符串；字符串只有空格字符）

**本题考点**

- 字符串的编程能力;
- 分析时间复杂度的能力；
- 是否能发现内存覆盖所存在的问题。在分析得知字符串会变长之后，应该意识到这个问题，本与面试官沟通。

**相关题目**

有两个排序的数组A1和A2，内存在A1的末尾有足够多的多余空间容纳A2。请实现一个函数，把A2中的所有数字插入A1中，并且所有的数字是排序的。

思考：在合并两个数组（包括字符串）时，如果从前往后复制每个数字（或字符）则需要重复移动数字（或字符）多次，那么考虑从后往前复制，这样就可以减少移动的次数，从而提高效率。采用双索引或者双指针遍历，知道其中一个数组遍历完即可。

疑问：两个数组分别有没有重复的元素，且两个数组之间有没有重复的元素。

### 链表

链表是面试时被提及最频繁的数据结构。

链表是一种动态数据结构，是因为在创建链表时，无须知道链表的长度。

如果想在链表中找到它的第i个节点，那么我们只能从头节点开始，沿着指向下一个节点的指针遍历链表，它的时间效率为O(n)。而在数组中，我们可以根据下标在O(1)时间内找到第i个元素。

#### 面试题6：从尾到头打印链表

>题目：输入一个链表的头结点，从尾到头反过来打印出每个节点的值。链表节点定义如下：

```c++
struct ListNode
{
    int m_nKey;
    ListNode* m_pNext;
}
```

**提示**

*在面试中，如果我们打算修改输入的数据，最好先问面试官是不是允许修改。*

通常打印是一个只读操作，我们不希望打印时修改内容。

链表的遍历顺序是从头到尾，可输出的书序却是从尾到头。也就是说，第一个遍历到的节点最后一个输出，而最后遍历到的节点第一个输出。这是一个典型的“后进先出”，可以用栈来实现。由于递归的本质就是一个栈结构，所以可以用递归来实现。

### 树

数有如下几种遍历方式。

- 前序遍历：先访问根节点，再访问左子节点，最后访问右子节点。
- 中序遍历：先访问左子节点，再访问根节点，最后访问右子节点。
- 后序遍历：先访问左子节点，再访问右子节点，最后访问根节点。

这3种遍历都有递归和循环两种不同的实现方法，每种遍历的递归实现都比循环实现要简洁很多。

- 宽度优先遍历：先访问数的第一层节点，再访问树的第二层节点……一直到最后一层节点。在同一层节点中，以从左到右的顺序依次访问。

二叉搜索树：左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点。在二叉搜索树中找到一个节点的平均时间复杂度位$O(logn)$。

堆：分为最大堆和最小堆。在最大堆中根节点的值最大，在最小堆中根节点的值最小。有很多需要快速找到最大值或最小值的问题都可以用堆来解决。

红黑树：其把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶子节点的最长路径的长度不超多最短路径的两倍。在C\+\+的STL中，set、multiset、map、multimap等数据结构都是给予红黑树实现的。

#### 面试题7：重建二叉树

> 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。

在二叉树的前序遍历序列中，第一个数字总是树的根节点的值。但在中序遍历序列中，根节点的值在序列的中间，左子树的节点的值位于根节点的值的左边，而右子树的节点的值位于根节点的值的右边。

**测试用例**

- 普通二叉树（完全二叉树；不完全二叉树）；
- 特殊二叉树（所有节点都没有右子节点的二叉树；所有节点都没有左子节点的二叉树；只有一个节点的二叉树）
- 特殊输入测试（二叉树的根节点为nullptr；<font color=red>输入的前序遍历和中序遍历序列不匹配</font>）。

**本题考点**

- 对前序遍历和中序遍历的理解
- 分析复杂问题的能力。其可以把构建二叉树的大问题分解为构建左、右子树的两个小问题。小问题和大问题的本质是一致的，因此可以用递归的方式解决。

#### 面试题8：二叉树的下一个节点

> 题目：给定一颗二叉树和其中的一个节点，如何找出中序遍历的下一个节点？树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。

如果一个节点有右子树，那么它的下一个节点就是它的右子树中最左子节点。也就是说，从右子节点出发一直沿着左子节点的指针，就可以找到它的下一个节点。

接下来分析一个节点没有右子树的情形。如果节点是它父节点的左子节点，那么它的下一个节点就是它的父节点。

如果一个节点既没有右子树，并且它还是父节点的右子节点，那么这种情形就比较复杂。我们可以沿着父节点的指针一直向上遍历，直到找到一个是它父节点左子节点的节点。如果这样的节点存在，那么这个节点的父节点就是我们要找的下一个节点。

**测试用例**

- 普通二叉树
- 特殊二叉树
- 不同位置的节点的下一个节点（下一个节点为当前节点的右子节点、右子树的最左子节点、父节点、跨层父节点等；当前节点没有下一个节点）。

**本题考点**

- 考查二叉树中序遍历的理解程度。
- 考察分析复杂问题的能力。应聘者只有画出二叉树的结构图、通过具体例子找出中序遍历下一个节点的规律，才有可能设计出可行的算法。

### 栈和队列

操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址及临时变量等。栈的特点是后进先出。

队列的特点是先进先出。

#### 面试题9：用两个栈实现队列

> 题目：用两个栈实现一个队列，队列的生命如下，请实现他的两个函数appendTail和deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。

本题的意图是要求我们操作两个“先进后出”的栈实现一个“先进先出”的队列。

将要添加的元素插入到stack1中，由于栈是先进后出的，如果要删除元素，就在把stack1的元素从栈顶弹出插入到stack2中，这时候stack1最先插入的元素（也就是栈底元素）其在stack2的栈顶，就可以通过弹出stack2栈顶的元素完成删除的操作。

 总结删除一个元素的步骤：当stack2不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。当stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压到stack1的底端，经过弹出和压入操作之后就处于stack2的顶端，又可以直接弹出。

**相关题目**

> 用两个队列实现一个栈

首先不妨把a插入queue1。接下来继续往其插入b、c两个元素。此时a位于queue1的头部，c位于队列的尾部。

根据栈的后入先出原则，最后被压入栈的c应该最先被弹出。由于c位于queue1的尾部，而我们只能从队列的头部删除元素，因此我们可以先从queue1中依次删除a、b并插入queue2，再从queue1中删除元素c。这就相当于从栈中弹出元素c。我们可以用同样的方法从栈中弹出元素b。

接下来我们考虑往栈内压入一个元素d。

## 算法和数据操作

很多算法都可以用递归和循环两种不同的方式实现。通常基于递归的实现方法代码会比较简洁，但性能不如基于循环的实现方法。在面试的时候，可以根据题目的特点，甚至可以和面试官讨论选择合适的方法编程。

通常排序和查找是面试时考查算法的重点。在准备面试的时候，我们应该重点掌握二分查找、归并排序和快速排序。

如果面试题要求在二维数组（可能具体表现为迷宫或棋盘等）上搜索路径，那么我们可以尝试用回溯法。通常回溯法很适合用递归的代码实现。只有当面试官限定不可以用递归实现的时候，我们再考虑用栈来模拟递归的过程。

如果面试题是求某个问题的最优解，并且该问题可以分为多个子问题，那么我们可以尝试用动态规划。在用自上而下的递归思路去分析动态规划问题的时候，我们会发现子问题之间存在重叠的更小的子问题。为了避免不必要的重复计算，我们用自下而上的循环代码来实现，也就是把子问题的最优解先算出来并用数组（一般是一维或者二维数组）保存下来，接下来基于子问题的解计算最大问题的解。

如果我们告诉面试官动态规划的思路之后，面试官还在说分解子问题的时候是不是存在某个特殊的选择，如果采用这个特殊的选择将一定能得到最优解，那么，通常面试官这样的提示意味着该面试题可能适用贪婪算法。当然，面试官也会要求应聘者证明贪婪选择的确能够得到最优解。

位运算可以看成一类特殊的算法，它是把数字表示成二进制之后对0和1的操作。由于位运算的对象为二进制数字，所以不是很直观，但掌握它也不难，因为总共只有与、或、异或、左移和右移5种位运算。

### 递归和循环

在面试的时候，如果面试官没有特别的要求，应聘者可以尽量多采用递归的方法编程。

**提示：**

> 通常给予递归的代码比基于循环实现的代码要简洁很多，更加容易实现。

递归虽然有简洁的优点，但它同时也有显著的缺点。递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间。所以递归实现的效率不如循环。

递归的本质是把一个问题分解为两个或者多个小问题。如果多个小问题存在相互重叠的部分，就存在重复的计算。

通常应用动态规划解决问题时我们都是用递归的思路分析问题，但由于递归分解的子问题中存在大量的重复，因此我们总是用自下而上的循环来实现代码。

除效率之外，递归还有可能引起更严重的问题：调用栈溢出。每一次函数调用在内存栈中分配空间，而每个进程的栈容量有限。当递归调用的层级太多时，就会超出栈的容量。从而导致调用栈溢出。

#### 面试题10：斐波那契数列
> 题目一：求斐波那契数列的第n项
> 写一个函数，输入n，求斐波那契数列的第n项。斐波那契数列的定义如下：

$$
u(x) = 
\begin{cases}
0 & n = 0\\
1 & n = 1\\
f(n-1)+f(n-2) & n > 1
\end{cases}
$$

**效率很低的解法**

```c++
long long Fibonacci(unsigned int n)
{
    if(n <= 0)
        return 0;
    if(n == 1)
        return 1;
    
    return Fibonacci(n-1) + Fibonacci(n-2);
}
```

举例可以发现在递归的过程中，有很多节点是重复计算的，随着n的增大而急剧增加。事实上，用递归方法计算的时间复杂度是以n的指数的方式递增的。

**面试官期待的实用解法**

上述递归代码之所以慢，是因为重复的计算太多，所以要想办法避免重复的计算。比如我们可以把已经得到的数列中间项保存起来，在下次需要计算的时候我们先查找一下。如果前面已经计算过就不用再重复计算了。

更简单的办法是从下往上计算，首先根据$f(0)$和$f(1)$计算出$f(2)$，再根据$f(1)$和$f(2)$计算出$f(3)$……以此类推就可以计算出第n项了。

**时间复杂度$O(logn)$但不够实用的解法**

该方法利用了一个数学公式：
$$
\left[
\begin{matrix}
f(n) & f(n-1) \\
f(n-1) & f(n-2)
\end{matrix}
\right]
=
\left[
\begin{matrix}
1 & 1 \\
1 & 0
\end{matrix}
\right]^{n-1}
$$
这个公式用数学归纳法不难证明，则只需求得$\left[\begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right]^{n-1}$即可得到$f(n)$。现在的问题转换为如何求$\left[\begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right]$的乘法。n的次方需要n次运算，则其时间复杂度仍然是$O(n)$，并不比前面的方法快。但可以可以考虑乘法的如下性质：
$$
a^n = \begin{cases}
a^{n/2}\cdot a^{n/2} & n为偶数\\
a^{(n-1)/2}\cdot a^{(n-1)/2}\cdot a & n为奇数
\end{cases}
$$
从上面的公式中可以看出，若想求得n次方，就要先求得$n/2$次方，再把$n/2$次方的结果平方一下即可。这可以用递归的思路实现。虽然其可以用$O(logn)$求得矩阵的$n$次方，但由于隐含的时间常数较大，很少会有软件采用这种算法，另外，实现这种解法的代码也很复杂，不太适合面试。

> 题目二：青蛙跳台阶问题。
> 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法。

首先考虑最简单的情况。如果只有1级台阶，那显然只有一种跳法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级；另一种就是一次跳2级。

接着我们再来讨论一般情况。我们把n级台阶时的跳发看成n的函数，记为$f(n)$。当n>2时，第一次跳法就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为$f(n-1)$；二是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为$f(n-2)$。因此，n级台阶的不同跳法的总数$f(n)=f(n-1)+f(n-2)$。不难看出实际上就是斐波那契数列了。

**本题扩展**

在青蛙跳台阶的问题中，如果把条件改成：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级，此时该青蛙跳上一个n级的台阶总共有多少种跳法？我们用数学归纳法可以证明$f(n)=2^{n-1}$。

证明过程在**GoodNotes**->**想法**中。可以通过自己比较n和n-1的差异，以及找出n为1、2、3和4的方法数

**相关题目**

我们可以用$2\times1$的小矩形横着或竖着去覆盖更大的矩形。请问用8个$2\times1$的小矩形无重叠地覆盖一个$2\times8$的大矩形，总共有多少种方法？

我们先把$2\times8$的覆盖方法记为$f(8)$。用第一个$2\times1$的小矩形去覆盖大矩形的最左边时有两种选择：竖着放或者横着放。当竖着放的时候，右边还剩下$2\times7$的区域，这种情形下的覆盖方法记为$f(7)$。接下来考虑横着放的情况。当$2\times1$的小矩形横着放在左上角的时候，右下角必须跟着横着放一个$2\times1$的小矩形，而在右边还剩下$2\times6$的区域，这种情形下覆盖方法记为$f(6)$，因此$f(8)=f(7)+f(6)$。此时我们可以看出，这仍然是斐波那契数列。

### 查找和排序

查找相对而言较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。在面试的时候，不管是用顺序还是用递归，面试官都期待应聘者能够信手拈来写出完整正确的二分查找代码。

**面试小提示**

> 如果面试题是要求在排序的数组中查找一个数字或者统计某个数字出现的次数，那么我们都可以尝试用二分查找算法。

哈希表和二叉排序树查找的重点在于考查对应的数据结构而不是算法。哈希表最主要的优点是我们利用它能够在$O(1)$时间内查找某一元素，是效率最高的查找方式：但其缺点是需要额外的空间来实现哈希表。

排序比查找要复杂一些。面试官会经常要求应聘者比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。所以面试时一定要对各种排序算法的特点烂熟于胸，能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较它们的优缺点。

很多公司的面试官喜欢在面试环节要求应聘者写出快速排序的代码。应聘者不妨自己写一个快速排序的函数并用各种数据进行测试。当测试都通过之后，再和经典的实现进行比较，看看有什么区别。

实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数字中的数字分为两部分，比选择的数字小的数字移到数组左边，比选择的数字大的数字移到数组的右边。

```c++
int Partition(int data[], int length, int start, int end)
{
    // 还有一种情况end<0
    if(data == nullptr || length <= 0 || start < 0 || end >= length)
        throw "Invalid Parameters";
    int index = RandomInRange(start, end);
    Swap(&data[index],&data[end]);
    
    // 为什么small为start-1
    int small = start - 1;
    for(index = start; index < end; ++index)
    {
        if(data[index]<data[end])
        {
            ++small;
            if(small != index)
                Swap(&data[index], &data[small]);
        }
    }
    ++small;
    Swap(&data[small], &data[end]);
    
    return small;
}
```

函数RandomInRange用来生成一个在start和end之间的随机数，函数Swap的作用是用来交换两个数字。接下来我们可以用递归的思路分别对每次选中的数字的左右两边排序。下面就是递归实现快速排序的参考代码：

```c++
void QuickSort(int data[], int length, int start, int end)
{
    if(start == end)
        return;
    int index = Partition(data, length, start, end);
    if(index > start)
        QuickSort(data, length, start, index-1);
    if(index < end)
        QuickSort(data, length, index+1, end);
}
```

不同的排序算法适用的场合也不尽相同。快速排序虽然总体的平局效率是最好的，但也不是任何时候都是最优的算法。比如，数组本身已经排序了，而每一轮排序的时候都以最后一个数字作为比较的标准，此时快速排序的效率只有$O(n^2)$。在这种场合快速排序就不是最优的算法。在面试的时候，如果面试官要求实现一个排序算法，那么应聘者一定要问清楚这个排序应用的环境是什么，有哪些约束条件，在得到足够多的信息之后再选择最合适的排序算法。

<font color=red>其实这个快速排序算法有点不太理解，可以参考**大话数据结构**中的快速排序算法</font>

**面试官**：请实现一个排序算法，要求时间效率为$O(n)$。

**应聘者**：对什么数字进行排序，有多少个数字？

**面试官**：我们想对公司所有员工的年龄排序。我们公司总共有几万名员工。

**应聘者**：也就是说数字的大小是在一个较小的范围之内的，对吧？

**面试官**：嗯，是的。

**应聘者**：可以使用辅助空间吗？

**面试官**：看你用多少辅助内存。只允许使用常亮大小辅助空间，不得超过$O(n)$。

```c++
void SortAges(int ages[], int length)
{
    if(ages == nullptr || length <= 0)
        return;
    const int oldestAge = 99;
    int timesOfAge[oldestAge+1];
    
    // 这个初始化的方式是不是有点不好
    // 改为int timesOfAge[oldestAge+1] = {0};其在定义时就进行初始化
    // 但是int timeOfAge[oldestAge+1] = {1}；并不是全部元素为1
    // 所以有时还是循环复制比较好。
    for(int i=0; i<=oldestAge; ++i)
        timesOfAge[i] = 0;
    
    for(int i=0; i<length; ++i)
    {
        int age = ages[i];
        if(age<0||age>oldestAge)
            throw "age out of range.";
        ++timesOfAge[age];
    }
    
    int index = 0;
    for(int i=0; i<=oldestAge; ++i)
    {
        for(int j=0; j<timesOfAge[i]; ++j)
        {
            ages[index] = i;
            ++index;
        }
    }
}
```

公司员工的年龄有一个范围。在上面的代码中，允许的范围是0\~99岁。数组timesOfAge用来统计每个年龄出现的次数。某个年龄出现了多少次，就在数组ages里设置几次该年龄，这就相当于给数组ages排序了。该方法用长度100的整数数组作为辅助空间换来了$O(n)$的时间效率。

#### 面试题11：旋转数组的最小数字

> 题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。

这道题最直观的解法并不难，从头到尾遍历数组一次，我们就能找出最小的元素。这种思路的时间复杂度显然是$O(n)$。但是这种思路没有利用输入的旋转数组的特性，所以达不到要求。

容易发现旋转之后的数组实际上可以划分为两个排序的子数组，而且前面子数组的元素都大于或者等于后面子数组的元素。我们还注意到最小的元素刚好是这两个子数组的分界线。在排序的数组中我们可以用二分查找法实现$O(logn)$的查找。本题给出的数组在一定程度上是排序的，因此可以试着用二分查找法的思路来寻找这个最小的元素。

和二分查找法一样，我们用两个指针分别指向数组的第一个元素和最后一个元素。按照题目中旋转的规则，第一个元素应该是大于或者等于最后一个元素的（这其实不完全对（表示怀疑），还有特例，后面再加以讨论）。

接着我们可以找到数组中间的元素。如果该中间元素位于前面的递增子数组。那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于该中间元素的后面。我们可以把第一个指针指向该中间元素，这样可以缩小寻找的范围。移动之后的第一个指针仍然位于前面的递增子数组。

同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素的前面。我们可以把第二个指针指向该中间元素，这样也可以缩小寻找范围。移动之后的第二个指针仍然位于后面的递增子数组。

不管是移动第一个指针还是第二个指针，查找范围都会缩小到原来的一半。接下来我们再用更新之后的两个指针重复做新一轮的查找。

按照上述思路，第一个指针总是指向前面递增数组的元素，而第二个指针总是指向后面递增数组的元素。最终第一个指针将指向前面子数组的最后一个元素，而第二个指针会指向后面子数组的第一个元素。也就是它们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素。这就是循环结束的条件。

前面我们提到，在旋转数组中，由于是把递增排序数组前面的若干个数字搬到数组的后面，因此第一个数字总是大于或者等于最后一个数字。但按照定义还有一个特例：如果把排序数组的前面的0个元素搬到最后面，即排序数组本身仍然是这个数组的一个旋转。此时，数组中的第一个数字就是最小的数字。

**测试用例**

- 功能测试（输入的数组是升序数组的一个旋转，数组中有重复数字或者没有重复数字）。
- 边界值测试（输入的数组是一个升序排序的数组，只包含一个数字的数组）。
- 特殊输入测试（输入nullptr指针或者是<font color=red>不符合要求的数组</font>）

**本题考点**

- 考查应聘者对二分查找的理解。本题变换了二分查找的条件，输入的数组不是排序的，而是排序数组的一个旋转。
- 考查应聘者的沟通能力和学习能力。本题面试官提出了一个新的概念：数组的旋转。我们要在短时间内学习、理解这个新概念。在面试过程中，如果面试官提出新的概念，那么我们可以主动和面试官沟通，多问几个问题，把概念弄清楚。
- 考查应聘者思维的全面性。排序数组本身是数组旋转的一个特例。另外，我们要考虑到数组中有相同数字的特例。

### 回溯法

它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。我们就这样重复选择，直到到达最终的状态。

用回溯法解决的问题的所有选项可以形象地用树状结构表示。在某一步有n个可能的选项，那么该步骤可以看成是树状结构中的一个节点，每个选项看成树中节点连接线，经过这些连接线到达该节点的n个子节点。树的叶节点对应着终结状态。如果在叶节点的状态满足题目的约束条件，那么我们找到了一个可行的解决方案。

如果在叶子节点的状态不满足约束条件，那么只好回溯到它的上一个节点再尝试其他的选项。如果上一个节点所有可能的选项都已经试过，并且不能到达满足约束条件的终结状态，则再次回溯到上一个节点。如果所有节点的所有选项都已经尝试过仍然不能到达满足约束条件的终结状态，则该问题无解。

通常回溯法适合用递归实现代码。当我们到达某一个节点时，尝试所有可能的选项并在满足条件的前提下递归地抵达下一个节点。

#### 面试题12：矩阵中的路径

> 题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。

这是一个可以用回溯法解决的典型例题。首先，在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch，并且这个格子将对应于路径上的第i个字符。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么到相邻的格子寻找路径上的第i+1个字符。除矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程，直到路径上的所有字符都在矩阵中找到相应的位置。

由于回溯法的递归特性，路径可以被看成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这时候只好在路径上回到第n-1个字符，重新定位第n个字符。

**测试用例**

- 功能测试（在多行多列的矩阵中存在或者不存在路径）。
- 边界值测试（矩阵只有一行或者一列：矩阵和路径中所有字母都是相同的）。
- 特殊输入测试（输入nullptr指针）。

#### 面试题13：机器人的运动范围

> 题目：地上有一个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如k等于18时，机器人能够进入方格(35,37)，因为3+5+3+7=18。但它不能进入方格(35,38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

**测试用例**

- 功能测试（方格为多行多列；k为正数）
- 边界值测试（方格只有一行或者一列；k等于0）；
- 特殊输入测试（k为负数）。

**本题考点**

- 考查应聘者对回溯法的理解。通常物体或人在二维方格运动这类问题都可以用回溯法解决。
- 考查应聘者对数组编程的能力。我们一般都把矩阵看成一个二维的数组。

### 动态规划与贪婪算法

动态规划现在是编程面试中的热门话题。如果面试题是求一个问题的最优解（通常是求最大值或最小值），而且该问题能够分解成若干个子问题，并且子问题之间还有重叠的更小的子问题，就可以考虑用动态规划来解决这个问题。

我们在应用动态规划之前要分析能够把大问题分解成小问题，分解后的每个小问题是否也存在最优解。如果把小问题的最优解组合起来能够得到整个问题的最优解，那么我们可以应用动态规划解决这个问题。

其主要有以下特点：

- 求一个问题的最优解；
- 整体问题的最优解是以来各个子问题的最优解；
- 这些小问题之间还有相互重叠的更小的子问题；
- 从上往下分析问题，从下往上求解问题。

**算法图解：**

仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。

从动态规划问题得到的启示：

- 动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。
- 在问题可分离为彼此独立且离散的子问题时，就可使用动态规划来解决。

设计动态规划解决方案的通用技巧：

- 每种动态规划解决方案都涉及网格。
- 单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。
- 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴。

动态规划小结：

- 需要在给定约束条件下优化某种指标时，动态规划很有用。
- 问题可分解为离散子问题时，可使用动态规划来解决。
- 每种动态规划解决方案都涉及网格。
- 单元格中的值通常就是你要优化的值。
- 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。

#### 面试题14：剪绳子

> 题目：给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为$k[0],k[1],\cdots ,k[m]$。请问$k[0]\times k[1]\times \cdots\times k[m]$可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

假设绳子最初的长度为10，我们可以把绳子剪成长度分别为4和6的两段，也就是$f(4)$和$f(6)$都是$f(10)$的子问题。接下来分别求解这个这两个子问题。我们可以把长度为4的绳子剪成均为2的两段，即$f(2)$和$f(4)$的子问题。同样，我们也可以把长度为6的绳子剪成长度分别为2和4的两段，即$f(2)$和$f(4)$都是$f(6)$的子问题。我们注意到$f(2)$是$f(4)$和$f(6)$的公共的更小的子问题。

由于子问题在分解大问题的过程中重复出现，为了避免重复求解子问题，我们可以用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解。在应用动态规划解决问题的时候，我们总是从解决最小问题开始的，并把已经解决的子问题的最优解存储下来（大部分面试题都是存储在一维或者二维数组里），并把子问题的最优解组合起来逐步解决打的问题。

在应用动态规划的时候，我们每一步都可能面临若干个选择。在求解面试题14的时，我们在剪第一刀的时候就有n-1个选择。我们可以剪在长度为$1,2,\cdots ,n-1$的任意位置。由于我们事先不知道剪在哪个位置是最优的解法，只好把所有的可能都尝试一遍，然后比较得出最优的剪法，只好把所有的可能都尝试一遍，然后比较得出最优的剪法。如果用数学的语言来表示，这就是$f(n)=max(f(i)\times f(n-i))$，其中$0<i<n$。

贪婪算法和动态规划不一样。当我们应用贪婪算法解决问题的时候，每一步都可以做出一个贪婪的选择，基于这个选择，我们确定能够得到最优解。还是以剪绳子为例，如果绳子的长度大于5，则每次都剪出一段长度为3的绳子。接下来重复这个步骤，直到剩下的绳子的长度小于5。剪出一段长度为3的绳子，就是我们在每一步做出的贪婪选择。为什么这样的贪婪选择能得到最优解？这是我们应用贪婪算法时都需要问的问题，需要用数学公式证明贪婪选择是正确的。

**算法图解：**

贪婪算法就是：每步都采取最优的做法。用专业的术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。显然，贪婪算法并非在任何情况下都行之有效，但它易于实现！

在某些情况下，完美是优秀的敌人，有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场。贪婪算法是一种近似的算法。在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下：

- 速度有多快；
- 得到的近似解与最优解的接近程度。

旅商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。

NP完全问题的简单定义是，以难解著称的问题，如旅商问题和集合覆盖问题。

NP完全问题无处不在！所以需要能够判断出要解决的问题是否属于NP完全问题，这样就不用去寻找完美的解决方案，而是使用近似算法即可。

NP完全问题的一些特点：

- 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢；
- 设计“所有组合”的问题通常是NP完全问题；
- 不能将问题分成小问题，必须考虑各种可能的情况。这是NP完全问题；
- 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题；
- 如果问题设计集合（如广播集合）且难以解决，它可能就是NP完全问题；
- 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。

贪婪算法总结：

- 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解；
- 对于NP完全问题，还没有找到快速解决方案；
- 面临NP完全问题时，最佳的做法是使用近似算法；
- 贪婪算法易于实现、运行速度快，是不错的近似算法。

### 位运算

#### 面试题15：二进制中1的个数

> 题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如，把9表示成二进制1001，有2位是1。因此，如果输入9，则该函数输出2。

- 可能引起死循环的解法

  先判断整数二进制表示中最右边一位是不是1；接着把输入的整数右移一位，此时原来处于从右边数起的第二位被移到最右边了，再判断是不是1；这样每次移动一位，直到整个整数变为0为止。

  把整数右移一位和把整数除以2在数学上是等价的，但是除法的效率比移位运算要低得多，在实际编程中应尽可能地用移位运算符代替乘除法。

  这种解法当输入一个负数时，会陷入死循环。例如输入0x80000000，当把其右移一位时，其不是变为0x40000000，而是0xC0000000。这是因为移位前是一个负数，仍然要保证移位后是一个负数，因此移位后的最高位会设为1.如果一直做右移运算，那么最终这个数字就会变成0xFFFFFFFF而陷入死循环。

- 常规解法

  为了避免死循环，我们可以不右移输入的数字n。首先把n和1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1。这样持续左移就能判断n的每一位是否为1。

- 给面试官带来惊喜的解法

  首先先分析把一个数减去1的情况。如果一个整数不等于0，那么该整数的二进制表示中至少有一位是1。先假设这个数的最右边一位是1，那么减去1时，最后一位变成0而其他所有位都保持不变，也就是最后一位相当于做了取反操作，由1变成了0。

  接下来假设最后一位不是1而是0的情况。如果该整数的二进制表示中最右边的1位于第m位，那么减去1时，第m位由1变成0，而第m位之后的所有0都成为1，整数中第m位之前的所有位都保持不变。

  在前面两种情况中，我们发现把一个整数减去1，都是把最右边的1变成0，如果它的右边还有0，则所有的0都变成1，而它左边的所有位都保持不变。接下来我们把一个整数和它减去1的结果做位与运算，相当于把它最右边的1变成0。

  上面分析总结起来就是：把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0。那么一个整数二进制表示中有多少个1，就可以进行多少次这样的操作。

**测试用例**

- 正数（包括1边界值1、0x7FFFFFFF）。
- 负数（包括边界值0x80000000、0xFFFFFFFF）。
- 0。

**本题考点**

- 考查应聘者对二进制及位运算的理解
- 考查应聘者分析、调试代码的能力。如果应聘者在面试过程中采用的是第一种思路，则当面试官提示他输入负数将会出现问题时，面试官会期待他能在心中运行代码，自己找出运行出现死循环的原因。这就要求具有一定的调试功底。

**相关题目**

- 用一条语句判断一个整数是不是2的整数次方。一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是0。根据前面的分析，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变为0。
- 输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。比如10的二进制表示为1010,13的二进制表示为1101，需要改变1010中的3位才能得到1101。我们可以分为两步解决这个问题：第一步求这两个数的异或；第二步统计异或结果中1的位数。

**举一反三**

> 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1变成0。很多二进制的问题都可以用这种思路解决。






























