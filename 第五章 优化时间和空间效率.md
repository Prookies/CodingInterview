# 优化时间和空间效率

## 时间效率

首先，我们的编程习惯对代码的时间效率有很大影响。比如C/C\+\+程 序员要养成采用引用（或指针）传递复杂类型参数的习惯。如果采用值传 递的方式，则从形参到实参会产生一次复制操作。这样的复制是多余的操 作，我们应该尽量避免。

其次，即使同一个算法用循环和递归两种思路实现的时间效率可能会 大不一样。递归的本质是把一个大的复杂问题分解成两个或者多个小的简 单问题。如果小问题中有相互重叠的部分，那么直接用递归实现虽然代码显得更简洁，但时间效率可能会非常差。对于 这种类型的题目，我们可以用递归的思路来分析问题，但写代码的时候可 以用数组(一维或者多维数组)来保存中间结果基于循环实现。绝大部分 动态规划算法的分析和代码实现都是分这两个步骤完成的。

再次，代码的时间效率还能体现应聘者对数据结构和算法功成的掌握 程度。同样是査找，如果是顺序査找则需要0(n)的时间；如果输入的是排 序的数组则只需要O(logn)的时间：如果事先已经构造好了哈希表，那么査 找在0(1)时间内就能完成。我们只有对常见的数据结构和算法都了然于胸， 才能在需要的时候选择合适的数据结构和算法来解决问题。

最后，应聘者在面试的时候要展示敏捷的思维能力和追求完美的激情。 听到题目的时候，我们一般很快就能想到最直观的算法。这个最直观的办 法很有可能不是最优的，但也不妨在第一时间告诉面试官，这样面试官至 少会觉得我们思维比较敏捷。我们想到几种思路之后，面试官可能仍然不 满意，还在提示我们有更好的办法。这时候我们一定不能轻言放弃，而要 表现出枳极思考的态度，努力从不同的角度去思考问题。有些题目很难， 面试官甚至不期待应聘者在短短几十分钟里想出完美的解法，但他会希望 应聘者能够有激情、有耐心地去尝试新的思路，而不是碰到难题就退缩。 在面试的时候，应聘者的态度和激情对最终的面试结果也有很重要的影响。

###  面试题39：数组中出现次数超过一半的数字

>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这 个数字。

- 解法一：基于Partition函数的时间复杂度为O(n)的算法<font color=red>(不是O(nlogn)吗)</font>

  如果我们回到题目本身仔细分析，就会发现前面的思路并没有考虑到 数组的特性；数组中有一个数字出现的次数超过了数组长度的一半。如果 把这个数组排序，那么排序之后位于数组中间的数字一定就是那个出现次 数超过数组长度一半的数字。也就是说，这个数字就是统计学上的中位数， 即长度为n的数组中第n/2大的数字。我们有成熟的时间复杂度为0(n)的 算法得到数组中任意第k大的数字。

  这种算法受快速排序算法的启发。在随机快速排序算法中，我们先在 数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数 字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边。如 果这个选中的数字的下标刚好是n/2，那么这个数字就是数组的中位数；如 果它的下标大于那么中位数应该位于它的左边，我们可以接着在它的 左边部分的数组中査找；如果它的下标小于n/2,那么中位数应该位于它的 右边，我们可以接着在它的右边部分的数组中査找。这是一个典型的递归 过程。

- 解法二：根据数组特点找出时间复杂度为O(n)的算法

  接下来我们从另外一个角度来解决这个问题。数组中有一个数字出现 的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现 次数的和还要多。因此，我们可以考虑在遍历数组的时候保存两个值：一 个是数组中的一个数字；另一个是次数。当我们遍历到下一个数字的时候， 如果下一个数字和我们之前保存的数字相同，则次数加1：如果下一个数字 和我们之前保存的数字不同，则次数誠1。如果次数为零，那么我们需要保 存下一个数字，并把次数设为1.由于我们要找的数字出现的次数比其他所 有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设 为1时对应的数字。

**解法比较**

上述两种算法的时间都是O(n)。基于Partition函数的算法的时间复杂度的分析不是很直观，可以参考《算法导论》。在第一种解法中，需要交换数组中数字的顺序，这就会修改输入的数组。是不是可以修改输入的数组呢？在面试的时候，我们需要和面试官讨论，让他明确需求。如果面试官说不能修改输入的数组，那就只能采用第二种解法了。

**本题考点**

- 考查应聘者对时间其杂度的理解。应聘者每想出一种解法，面试官 都期待他能分析出这种解法的时间复杂度是多少。
-  考查应聘者思维的全面性。面试官除了要求应聘者能对有效的输 入返回正确的结果.同时也期待应聘者能对无效的输入进行相应 的处理。

### 面试题40：最小的k个数

> 题目：输入n个整数，找出其中最小的k个数。

这道题最简单的思路莫过于把输入的n个整数排序，排序之后位于最 前面的k个数就是最小的k个数。这种思路的时间复杂度是O(nlogn)，面试 官会提示我们还有更快的算法。

- 解法一：时间复杂度为O(n)的算法，只有当我们可以修改输入的数组时可用

  从面试题“数组中出现次数超过一半的数字”得到启发，我们同样可以基于Partition函数来解决这个问题。如果基于数组的第k个数字来调整，则使得比第k个数字小的所有数字都位于数组的左边，比第k个数 字大的所有数字都位于数组的右边。这样调整之后，位于数组中左边的k 个数字就是最小的k个数字(这k个数字不一定是排序的)。

- 解法二：时间复杂度度为O(nlogk)的算法，特别适合处理海量数据  

  我们可以先创建一个大小为k的数据容器来存储最小的k个数字，接下 来每次从输入的n个整数中读入一个数。如果容器中已有有的数字少于k个， 则直接把这次读入的整数放入容器之中；如果容器中已有k个数字了，也就是容器已满，此时我们不能再插入新的数字而只能替换己有的数字。找 出这已有的k个数中的最大值，然后拿这次待插入的整数和最大值进行比 较。如果待插入的值比当前己有的最大值小，则用这个数替换当前已有的 最大值；如果待插入的值比当前已有的最大值还要大，那么这个数不可能 是最小的k个整数之一，于是我们可以抛弃这个整数。

   因此，当容器满了之后，我们要做3件事情：一是在k个整数中找到 最大数：二是有可能在这个容器中删除最大数；三是有可能要插入一个新 的数字。如果用一棵二叉树来实现这个数据容器，那么我们能在O(logk)时 间内实现这3步操作。因此，对于n个输入数字而言，总的时间效率就是 O(nlogk)。

   我们可以选择用不同的二叉树来实现这个数据容器。由于每次都需要 找到k个整数中的最大数字，我们很容易想到用最大堆。在最大堆中，根 节点的值总是大于它的子树中任意节点的值。于是我们每次可以在O(1)时 间内得到已有的k个数字中的最大值，但需要O(logk)时间完成删除及插入 操作。 

  我们自己从头实现一个最大堆需要一定的代码，这在面试短短的几十 分钟内很难完成。我们还可以釆用红黑树来实现我们的容器.红黑树通过 把节点分为红、黑两种颜色并根据一些规则确保树在一定程度上是平衡的， 从而保证在红黑树中的査找、删除和插入操作都只需要O(logk)时间。在STL 中，set和multiset都是基于红黑树实现的。如果面试官不反对我们用STL 中的数据容器，那么我们可以直接拿过来用。multiset是可以自动排序的

**解法比较**

基于函数Partition的第一种解法的平均时间复杂度是0(n)，比第二种 解法要快，但同时它也有明显的限制，比如会修改输入的数组。

 第二种解法虽然慢一点，但它有两个明显的优点。一是没有修改输入 的数据。我们每次只是从data中读入数字，所有的写 操作都是在容器leastNumbers中进行的。二是该算法适合海量数据的输入 （包括百度在内的多家公司非常喜欢与海量输入数据相关的问题）。假设题目是要求从海量的数据中找出最小的k个数字，由于内存的大小是有限的， 有可能不能把这些海量的数据一次性全部载入内存。这个时候，我们可以 从辅助存储空间（如硬盘）中每次读入一个数字，根据GetLeastNumbers 的方式判断是不是需要放入容器leastNumbers即可。这种思路只要求内存 能够容纳leastNumbers即可，因此它最适合的情形就是n很大并且k较小 的问题。

![image-20200312232812812](E:\document\Learn\CodingInterview\image\image-20200312232812812.png)

由于这两种解法各有优缺点，各自适用于不同的场合，因此应聘者在 动手做题之前要先问清楚題日的要求，包括输入的数据量有多大、能否一 次性载入内存、是否允许交换输入数据中数字的顺序等。

**面试小提示：**

如果面试时遇到的面试题有多种解法，并且每种解法都各有优缺点， 那么我们要向面试官问清姓题目的要求、输入的特点，从而选择景合适的 解法。

**本题考点：**

- 考查应聘者对时间复杂度的分析能力。面试的时候每想出一种解 法，我们都要能分析出这种解法的时间复杂度是多少。
- 如果采用第一种思路。则本题考查应聘者对Partition函数的理解。 这个函数既是快速排序的基础。也可以用来查找n个数中第k大的 数字。
- 如果采用第二种思路，则本题考查应聘者对堆、红黑树等数据结构 的理解。当需要在某个数据容器内频繁查找及替换最大值时，我们 要想到二叉树是一个合适的选择，并能想到用堆或者红黒树等特殊 的二叉树来实现。

### 面试题41：数据流中的中位数

> 题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中独处偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

由于数据是从一个数据流中读出来的，因而数据的数目随着时间的变 化而増加。如果用一个数据容器来保存从流中读出来的数据，则当有新的 数据从流中读出来时，这些数据就插入数据容器。这个数据容器用什么数 据结构定义最合适呢？ 

数组是最简単的数据容器。如果数组没有排序，则可以用Partition函 数找出数组中的中位数（详见面试题39）。在没有排序的数组中插入一个数 字和找出中位数的时间受杂度分别是O(1)和O(n)。

 我们还可以在往数组里插入新数据时让数组保持排序。这时由于可能 需要移动O(n)个数，因此需要O(n)时间才能完成插入操作。在己经排好序 的数组中找出中位数是一个简单的操作，只需要O(1)时间即可完成。 

排序的链表是另外一种选择。我们需要O(n)时间才能在链表中找到合 适的位置插入新的数据。如果定义两个指针指向链表中间的节点（如果链 表的节点数目是奇数，那么这两个指针指向同一个节点），那么可以在 O(1)时间内得出中位数。此时的时间复杂度与基于排序的数组的时间复杂 度一样。

 二叉搜索树可以把插入新数据的平均时间降低到O(logn)。但是当二 叉搜索树极度不平衡从而看起来像一个排序的链表时，插入新数据的时间 仍然是O(n)。为了得到中位数，可以在二叉树节点中添加一个表示子树节 点数目的字段。有了这个字段，可以在平均O(logn)时间内得到中位数，但 最差情况仍然需要O(n)时间。

 为了避免二叉搜索树的最差情况，还可以利用平衡的二叉捜索树，即 AVL树。通常AVL树的平衡因子是左、右子树的高度差。可以稍作修改， 把AVL的平衡因子改为左、右子树节点数目之差。有了这个改动，可以用 O(logn)时间往AVL树中添加一个新节点，同时用O(1)时间得到所有节点的 中位数。 

AVL树的时间效率很高，但大部分编程语言的函数库中都没有实现这 个数据结构。应聘者在短短几十分钟内实现AVL树的插入操作是非常困难，于是我们不得不再分析还有没有其他的方法。

我们注意到整个数据容器被分隔成两部分。位于容器左边部分的数据 比右边的数据小。另外，P~1~指向的数据是左边部分最大的数，P~2~指向的数 据是左边部分最小的数。 

如果能够保证数据容器左边的数据都小于右边的数据，那么即使左、 右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得 到中位数。如何快速从一个数据容器中找出最大数？用最大堆实现这个数 据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆中 找出最小数。 因此，可以用如下思路来解决这个问题：用一个最大堆实现左边的数 据容器，用一个最小堆实现右边的数据容器。往堆中插入一个数据的时间 效率是0(logn)。由于只需要0(1)时间就可以得到位于堆顶的数据，因此得 到中位数的时间复杂度是0(1)。

 表5.2总结，使用没有排序的数组、排序的数组、排序的链表、二叉搜 索树、AVL数、最大堆和最小堆儿种不同的数据结构的时间复杂度。

| 数据结构       | 插入的时间复杂度      | 得到中位数的时间复杂度 |
| -------------- | --------------------- | ---------------------- |
| 没有排序的数组 | O(1)                  | O(n)                   |
| 排序的数组     | O(n)                  | O(1)                   |
| 排序的链表     | O(n)                  | O(1)                   |
| 二叉搜索树     | 平均O(logn)，最差O(n) | 平均O(logn)，最差O(n)  |
| AVL数          | O(logn)               | O(1)                   |
| 最大堆和最小堆 | O(logn)               | O(1)                   |

接下来考虑用最大堆和最小堆实现的一些细节。首先要保证数据平均 分配到两个堆中，因此两个堆中数据的数目之差不能超过1。为了实现平 均分配，可以在数据的总数目是偶数时把新数据插入最小堆，否则插入最 大堆。

 还要保证最大堆中的所有数据都要小于最小堆中的数据。当数据的 总数目是偶数时。按照前面的分配规则会把新的数据插入最小堆。如果此时 这个新的数据比最大堆中的一些数据要小，那该怎么办呢？

 可以先把这个新的数据插入最大堆，接着把最大堆中最大的数字拿出 来插入最小堆。由于最终插入最小堆的数字是原最大堆中最大的数字。这 样就保证了最小堆中所有数字都大于最大堆中的数字。 

当需要把一个数据插入最大堆，但这个数据小于最小堆里的一些数据 时，这个情形和前面类似，请大家自己分析。



使用树莓派相机进行监控，并将监控画面上传给服务器。如果识别到有人出现，就自动发送邮件到相关联系人。

**本题考点**

- 考查应聘者对时间复杂度的分析能力
- 考查应聘者对数据结构的理解程度。应聘者只有对各个常用数据容 器的特点非常了解，知道它们的优缺点及适用场景，才能找岀最优 的解法。

### 面试题：连续子数组的最大和

>题目：输入一个整型数组，数组里有正数也有负数。数组中的一个或 连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。

看到这道題，很多人都能想到最直观的方法，即枚挙数组的所有子数 组并求出它们的和。一个长度为n的数组，总共有n(n+1)/2个子数组。计 算出所有子数组的和，最快也需要0(n^2^)时间。通常最在观的方法不会是最 优的解法，面试官将提示我们还有更快的算法。

- 解法一：举例分析数组的规律

  我们试着从头到尾逐个累加示例数组中的每个数字。初始化和为0。第 一步加上第一个数字1，此时和为1。第二步加上数字-2，和就变成了 -1。第三步加上数字3。我们注意到由于此前累加的和是-1。小于0，那如果用 -1加上3，得到的和是2，比3本身还小。也就是说，从第一个数字开始的 子数组的和会小于从第三个数字开始的子数组的和。因此，我们不用考考虑从第一个数字开始的子数组，之前累加的和也被抛弃。

  我们从第三个数字重新新开始累加，此时得到的和是3。第四步加10, 得到的和为13。第五步加上-4，和为9。我们发现，由于-4是一个负数， 因此累加-4之后得到的和比原来的和还要小。因此，我们要把之前得到的 和13保存下来，因为它有可能是最大的子数组的和。第六步加上数字7，9 加7的结果是16，此时的和比之前最大的和13还要大，把最大的子数组的 和由13更新为16。第七步加上2，累加得到的和为18，同时更新最大子数组的和。第八步加上最后一个数字-5，由于得到的和为13。小于此前最大 的和18,因此.最终最大的子数组的和为18,对应的子数组是{3, 10, -4, 7,  2}。

  面试的时候我们要考虑无效的输入，如输入的数组参数为空指针、数 组长度小于等于0等情况。此时我们让函数返回什么数字？如果返回0,那 我们又怎么区分子数组的和的最大值是0和无效输入这两种不同情况呢？ 因此，我们定义了 -个全局变最来标记是否输入无效

- 解法二：应用动态规划法

  如果算法的功底足够扎实，那么我们还可以用动态规划的思想来分析 这个问题。如果用函数$f(i)$表示以第$i$个数字结尾的子数组的最大和，那么 我们需要求出$max[f(i)]$，其中$0\leq i<n$ 我们可用如下递归公式求$f(i)$：
  $$
  f(i) =
  \begin{cases}
  pData[i] &i=0或者f(i-1)\leq 0\\
  f(i-1)+pData[i] &i\neq 0并且f(i-1)>0
  \end{cases}
$$
  这个公式的意义：当以第i-1个数字结尾的子数组中所有数字的和小于 0时，如果把这个负数与第i个数相加，则得到的结果比第i个数字本身还要 小，所以这种情况下以第i个数字结尾的子数组就是第i个数字本身。如果以第i-1个数字结尾的子数组中所有数字的和大于0， 则与第i个数字累加就得到以第i-1个数字结尾的子数组中所有数字的和。
  

 虽然通常我们用递归的方式分析动态规划的问题，但最终都会基于循 环去编码。上述公式对应的代码和前面给出的代码一致。因此，可以说这两 种思路是异曲同工的。

### 面试题43：1\~n整数中1出现的次数

> 题目：输入一个整数。，求1〜”这”个整数的十进制表示中1出现赤 次数,例如，输入12, 1〜12这些整数中包含1的数字有1、10、II和12, 1 一共出现了 5次.

- 不考虑时间效率的解法，靠它想拿Offer有点难 

  如果在面试的时候碰到这个问题，则应聘者大多能想到最直观的方法， 也就是累加1~n中每个整数1出现的次数中每个整数1出现的次数。我们可以每次通过对10求余 数判断整数的个位数字是不是1。如果这个数字大于10，则除以10之后再 判断个位数字是不是1。

  在上述思路中，我们对每个数字都要做除法和求余运算，以求出该数 字中1出现的次数。如果输入数字n，n有0(logn)位，我们需要判断每一 位是不是1，那么它的时间复杂度是O(nlogn)。当输入的n非常大的时候， 需要大量的计算，运算效率不高。面试官不会满意这种算法，我们仍然需 要努力。

- 从数字规律着手明显提高时间效率的解法，能让面试官耳目一新

  如果希望不用计算毎个数字的1的个数，那就只能去寻找1在数字中 出现的规律了。为了找到规律，我们不妨用一个稍微大一点的数字如21345 作为例子来分析。我们把1\~21345的所有数字分为两段：一段是1\~1345： 另一段是1346\~21345。 

  我们先看1346\~21345中1出现的次数。1的出现分为两种情况。首先 分析1出现在最高位(本例中是万位)的情况。在1346\~21345的数字中， 1出现在10000\~19999这10000个数字的万位中，一共出现了 10000 (10^4^)次。

   值得注意的是，并不是对所有5位数而言在万位出现的次数都是10000 次。对于万位是1的数字如输入12345，1只出现在10000\~12345的万位，出现的次数不是10^4^次，而是2346次，也就是除去最高数字之后剩下的数 字再加上1(2345+1=2346次)。 接下来分析1出现在除最高位之外的其他4位数中的情况。例子中 1346\~21345这20000个数字中后4位中1出现的次数是8000次。由于最 高位是2，我们可以再把1346\~21345分成两段：1346\~11345和11346\~21345。毎一段剩下的4位数字中，选择其中一位是1。其余三位可以在0~9这10个数字中任意选择，因此根据排列组合原则，总共出现的次数是$2\times 4\times 10^3=8000$次。

  至于在1\~1345中1出现的次数，我们就可以用递归求得了。这也是我们为什么要把1\~21345分成1\~1345和1346\~21345两段的原因。因为把21345的最高位去掉就成1345，便于我们采用递归思路。

  这种思路是每次去掉最高位进行递归，递归的次数和位数相同。一个 数字n有因此这种思路的时间复杂度是O(logn)，比前面的原始 方法要好很多。

**本题考点**

- 考查应聘者做优化的激情和能力。最原始的方法大部分应聘者都能 想到。当面试官提示还有更快的方法之后，应聘者千万不要轻易放 弃尝试。虽然想出时间复杂度为O(logn)的方法不容易，但应聘者 要展示自己追求更快算法的激情，多尝试不同的方法，必要的时 候可以要求面试官给出提示，但不能轻易说自己想不出来并且放 弃努力。
- 考查应聘者面对复杂问题的思维能力。要想找到时间复杂度为 O(logn)的方法，应聘者需要有严密的数学思维能力，并且还要通 过分析具体例子一步步找到通用的规律。这些能力在实际工作中面 对复杂问题的时候都非常有用。

### 面试题44：数字序列中某一位的数字

> 题目：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。

在面试的时候，很多应聘者都能想到最直观的方法，也就是从0开始逐一枚举每个数字。每枚挙一个数字的时候，求出该数字是几位数（如15 是2位数、9323是4位数），并把该数字的位数和前面所有数字的位数累加。 如果位数之和仍然小于或者等于输入n，则继续枚挙下一个数字。当累加的 数位大于n时，那么第n位数字一定在这个数字里，我们再从该数字中找 出对应的那一位。<font color=red>（看不懂，大概懂了）</font>

还有没有更快一些的办法。比如我们是不是可以找出某些规律从而跳 过若干数字？接下来用一个具体的例子来分析如何解决这个问题。比如， 序列的第1001位是什么？

 序列的前10位是0\~9这10个只有一位的数。显然第1001位在这 10个数字之后，因此这10个数字可以直接跳过。我们再从后面紧跟着的序 列中找第991 (991=1001-10)位的数字。 

接下来180位数字是90个10\~99的两位数。由于991>180，所以第 991位在所有的两位数之后。我们再跳过90个两位数，继续从后面找881 (881=991-180)位。

 接下来的2700位是900个100\~999的三位数。由于81<2700，所以 第811位是某个三位数中的一位。由于811=270X3+1，这意味着第811位是 从100开始的第270个数字即370的中间一位，也就是7。

**本题考点**

- 考查应聘者做优化的激情和能力。最直观的方法很多应聘者都能想 到。当面试官提示还有更快的方法之后，应聘者千万不要轻易放弃 尝试。虽然想出好的方法不容易，但应聘者要展示自己追求更快算 法的激情，多尝试不同的方法，必要的时候可以要求面试官给出提 示，但不能轻易说自己想不出来并且放弃努力。
- 考查应聘者面对复杂问题的思维能力。应聘者需要有严密的数学思 维能力，并且还要通过分析具体例子一步步找到通用的规律，才能 想出好的算法。这些能力在实际工作中面对复杂问题的时候都非常 有用。

### 面试题45：把数组排成最小的数（<font color=red>可以再做一次</font>）

> 题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数。 打印能拼接出的所有数字中最小的一个。例如，输入数组{3, 32, 321}，则打 小数字321323.

这道题最直接的解法应该是先求出这个数组中所有数字的全排列，然 后把每个排列拼起来，最后求出拼起来的数字的最小值。求数组的排列和 面试题38“字符串的排列”非常类似，这里不再详细介绍。根据排列组合 的知识，n个数字总共有n!个排列。我们再来看一种更快的算法。

 这道题其实是希望我们能找到一个排序规则，数组根据这个规则排序 之后能排成一个最小的数字。要确定排序规则，就要比较两个数字，也就 是给出两个数字m和n，我们需要确定一个规则判断m和n哪个应该排在 前面，而不是仅仅比较这两个数字的值哪个更大。

 根据题目的要求，两个数字用m和n能拼接成数字mn和nm。如果mn<nm， 那么我们应该打印出mn，也就是m应该排在n的前面，我们定义此时m 小于n；反之，如果nm<mn，则我们定义n小于m：如果mn=nm，则m等于n。在下文中，符号"<"、">"及"="表示常规意义的数值大小关系，而文字“大于”、“小于”、“等于”表示我们新定义的大小关系。

**本题考点**

- 本题有两个难点：第一个难点是想出一种新的比较规则来排序一个数组；第二个难点是证明这个比较规则是有效的，并且证明根据这 个规则排序之后，把数组中所有数字拼接起来得到的数字是最小 的。要想解决这两个难点，要求应聘者有很强的数学功底和逻辑思 维能力。
- 考査应聘者解决大数问题的能力。应聘者在面试的时候要意识到， 把两个int型的整数拼接起来得到的数字可能会超出int型数字能 够表达的范围，从而导致数字溢出。我们可以用字符申表示数字， 这样就能简单地解决大数问题。



### 面试题46：把数字翻译成字符串

>题目：给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成“a”，1翻译成“b”，……，11翻译成“1”，……，25翻译成“z”。一个数字可能有多个翻译。例如，12258有5种不同的翻译，分别是“bccfi”、“bwfi”、“bczi”、“mcfi”和“mzi”。请编程实现一个函数，用来计算一个数字有多 少种不同的翻译方法。

我们以12258为例分析如何从数字的第一位开始一步步计算不同翻译 方法的数目。我们有两种不同的选择来翻译第一位数字1。第一种选择是数 字1单独翻译成“b”，后面剩下数字2258；第二种选择是1和紧挨着的2 一起翻译成“m”，后面剩下数字258。 

当最开始的一个或者两个数字被翻译成个字符之后，我们接着翻译 后面剩下的数字。显然，我们可以写一个递归函数来计算翻译的数目。

 我们定义函数$f(i)$表示从第$i$位数字开始的不同翻译的数目，那么 $f(i)=f(i+1)+g(i,i+1)\times f(i+2)$。当第$i$位和第$i+1$位两位数字拼接起来的数字在 10\~25的范围内时，函数$g(i,i+1)$的值为1；否则为0。

 尽管我们用递归的思路来分析这个问题，但由于存在重复的子问题， 递归并不是解决这个问题的最佳方法。还是以12258为例。如前所述，翻译12258可以分解成两个子问题：翻译1和2258，以及翻译12和258。接 下来我们翻译第一个子问题中剩下的2258，同样也可以分解成两个自问题： 翻译2和258，以及翻译22和58。注意到子问题翻译258重复出现了。 递归从最大的问题开始自上而下解决问题。我们也可以从最小的子问 题开始自下而上解决问题，这样就可以消除重复的子问题。也就是说，我们从数字的末尾开始，然后从右到左翻译并计算不同翻译的数目。

**本题考点**

- 考查应聘者分析问题的能力。应聘者能够在问题中分析出递归的表达 式是解决这个问题的前提。
- 考查应聘者对递归及时间效率的理解。如果只是能够把递归分析转 换为递归代码，则应聘者不一定能够通过这道题的面试。面试官期 待应聘者能够用基于循环的代码来避免不必要的重复计算。

### 面试题47：礼物的最大价值

> 题目：在一个$m\times n$的棋盘的毎一格都放有一个礼物，每个礼物都有T 的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并 每次向左或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘及其 面的礼物，请计算你最多能拿到多少价值的礼物？



这是一个典型的能用动态规划解决的问题。我们先用递归的思路来分 析。我们先定义第一个函数$f(i,j)$表示到达坐标为$(i,j)$的格子时能拿到的礼物 总和的最大值。根据题目要求，我们有两种可能的途径到达坐标为$(i,j)$的格子：通过格子$(i-1,j)$或者$(i,j-1)$。所以$f(i,j)=max(f(i-1,j),f(i,j-1))+gift[i,j]$表示坐标为$(i,j)$的格子里礼物的价值。

尽管我们用递归来分析问题，但由于有大最重复的计算，导致递归的 代码并不是最优的。相对而言，基于循环的代码效率要髙很多。为了缓存 中间计算结果，我们需要一个辅助的二维数组。数组中坐标为$(i,j)$的元素表 示到达坐标为$(i,j)$的格子时能拿到的礼物价值总和的最大值。

接下来我们考虑进一步的优化。前面我们提到，到达坐标为$(i,j)$的格子 时能够拿到的礼物的最大价值只依赖坐标为$(i-1,j)$和$(i,j-1)$的两个格子，因 此第$i-2$行及更上面的所有格子礼物的最大价值实际上没有必要保存下来。 我们可以用一个一维数组来替代前面代码中的二维矩阵maxValues。该一维 数组的长度为棋盘的列数n。当我们计算到达坐标为$(i,j)$的格子时能够拿到的礼物的最大价值$f(i,j)$，数组中前j个数字分别是$f(i,0),f(i,1),\cdots,f(i,j-1)$，数 组从下标为$j$的数字开始到最后一个数字，分别为$f(i-1,j),f(i-1,j+1),\cdots,f(i-1,n-1)$ 。也就是说，该数组前面$j$个数字分别是当前第$i$行前面$j$个格子 礼物的最大价值，而之后的数字分别保存前面第$i-1$行$n-j$个格子礼物的最 大价值。

**本题考点**

- 考查应聘者用动态规划分析问题的能力。应聘者能够熟练应用动态 规划分析向题是解答这道面试题的前提。
- 考查应聘者对递归及时间效率的理解。如果只是能够把递归分析转 换为递归代码，则应聘者不一定能够通过这道题的面试。面试官期 待应聘看能够用基于循环的代码来避免不必要的重复计算。

### 面试题48：最长不含重复字符的子字符串

>题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长字符串的长度。假设字符串中只包含'a'\~'z'的字符。例如，在字符串"arabcacfr"中，最长的不含有重复字符的子字符串是"acfr"，长度为4。

我们不难找出字符串的所有子字符串，然后就可以判断每个子字符串 中是否包含重复的字符。这种蛮力法唯一的缺点就是效率。一个长度为n 的字符串有O(n^2^)<font color=red>（感觉不对）</font>个子字符串。我们需要O(n)的时间判断一个子字符串中是 否包含重复的字符，因此该解法的总的时间效率是O(n^3^) 。

接下来我们用动态规划算法来提高效率。首先定义函数$f(i)$表示以第i 个字符为结尾的不包含重复字符的子字符串的最长长度。我们从左到右逐 一扫描字符串中的每个字符。当我们计算以第i个字符为结尾的不包含重复 字符的子字符串的最长长度$f(i)$时，我们已经知道$f(i-1)$了。

 如果第i个字符之前没有出现过，那么$f(i)=f(i-1)+1$。例如，在字符串 "arabcacfr"中，显然$f(0)$等于1。在计算$f(1)$时，下标为1的字符'r'之前没有 出现过。因此$f(1)$等于2，即$f(1)=f(0)+1$。到目前为止，最长的不含重复字 符的子字符串是"ar"。

 如果第i个字符之前已经出现过，那情况就要复杂一点了。我们先计算第i个字符和它上次出现在字符串中的位置的距离，并记为d，接着分两种 情形分析。第一种情形是d小于或者等于$f(i-1)$，此时第i个字符上次出现 在$f(i-1)$对应的最长子字符串之中，因此$f(i)=d$。同时这也意味着在第i个字 符出现两次所夹的子字符串中再也没有其他重复的字符了。在前面的例子 中，我们继续计算$f(2)$，即以下标为2的字符'a'为结尾的不含重复字符的子 字符串的最长长度。我们注意到字符才在之前出现过，该字符上一次出现在 下标为0的位置，它们之间的距离d为2，也就是字符'a'可出现在人$f(1)$对应的 最长不含重复字符的子字符串"ar"中，此时$f(2)=d$，即$f(2)=2$，对应的最长 不含重复字符的子字符串是"ra"。 

第二种情形是d大于$f(i-1)$，此时第i个字符上次出现在$f(i-1)$对应的最 长子字符串之前，因此仍然有$f(i)=f(i-1)+1$。我们接下来分析以字符串 "arabcacfr"最后一个字符'r'为结尾的最长不含重复字符的子字符串的长度， 即求$f(8)$。以它前一个字符'f'为结尾的最长不含重复字符的子字符串是"acf"， 因此$f(7)=3$。我们注意到最后一个字符'r'之前在字符串"arabcacfr"中出现过，上一次出现在下标为1的位置，因此两次出现的距离d等于7，大于$f(7)$。 这说明上一个字符'r'不在$f(7)$对应的最K不含重复字符的子字符串"acf"中， 此时把字符'r'拼接到"acf"的后面也不会出现重复字符。因此$f(8)=f(7)+1$。即 $f(8)=4$，对应的最长不含重复字符的子字符串是"acfr"。

**本题考点**

- 考查应聘者用动态规划分析问题的能力。应聘者能够熟练应用动态 规划分析问题是解答这道面试题的前提。
- 考查应聘者对递归及时间效率的理解。如果只是能够把递归分析转 换为递归代码，则应聘者不一定能够通过这道题的面试。面试官期 待应聘者能够用基于循环的代码来避免不必要的重复计算。

## 时间效率与空间效率的平衡

在面试的时候，如果我们分配少量的辅助空间来保存计算的中间结果 以提高时间效率，则通常是可以被接受的。

值得注意的是。“以空间换时间”的策略并不一定都是可行的，在面试 的时候要具体问题具体分析。我们都知道在n个无序的元素里执行査找操 作，需要O(n)的时间。但如果我们把这些元素放进一个哈希表，那么在哈 希表内就能实现时间复杂度为O(1)的査找。但同时实现一个哈希表是有空 间消耗的，是不是值得以多消耗空间为前提来换取时间性能的提升，我们 需要根据实际情况仔细权衡。

很多时候时间效率和空间效率存在类似于鱼与熊掌的关系，我们需要 在它们之间有所取舍。在面试的时候究竟是“以时间换空间”还是“以空 间换时间”，我们可以和面试官进行探讨。多和面试官进行这方面的讨论是 很有必要的，这既能显示我们的沟通能力，又能展示我们对软件性能全方 位的把握能力。

### 面试题49：丑数

> 题目：我们把质包含因子2、3和5的数称作丑数。求按从小到大的顺序的第1500个丑数。例如，6、8都是是丑数，但14不是， 因为它包含因子7，习惯上我们把1当作第一个丑数。

- 逐个判断每个整数是不是丑数的解法，直观但不够高效 

  所谓一个数m是另一个数n的因子，是指n能被m整除，也就是$n\%m=0$。根据丑数的定义，丑数只能被2、3和5整除。也就是说，如果一个数 能被2整除，就连续除以2；如果能被3整除，就连续除以3；如果能被5 整除，就除以连续5。如果最后得到的是1，那么这个数就是丑数：否则不 是。

  我们只需要在函数GetUglyNumber中传入参数1500，就能得到第1500个丑数。该算法非常直观，代码也非常简洁，但最大的问题是每个整数都需要计算。即使-•个数字不是丑数，我们还站需要对它执行求余数和除法 操作•因此该算法的时间效率不是很高

  

- 创建数组保存已经找到的丑数，用空间换时间的解法

  前面的算法之所以效率低，很大程度上是因为不管一个数是不是丑数， 我们都要对它进行计算。接下来我们试着找到一种只计算丑数的方法，而 不在非丑数的整数上花费时间。根据丑数的定义，丑数应该是另一个丑数 乘以2、3或者5的结果(1除外)。因此，我们可以创建一个数组，里面的 数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。

   这种思路的关键在于怎样确保数组里面的丑数是排好序的。假设数组 中已经有若干个排好序的丑数，并且把已有最大的丑数记作M，接下来分 析如何生成下一个丑数。该丑数肯定是前面某一个丑数乘以2、3或者5的 结果，所以我们首先考虑把已有的每个丑数乘以2。在乘以2的时候，能得 到若干个小于或等于M的结果。由于是按照顺序生成的，小于或者等于M 肯定已经在数组中了，我们不需再次考虑：还会得到若干个大于M的结果， 但我们只需要第一个大于M的结果，因为我们希望丑数是按从小到大的顺 序生成的，其他更大的结果以后再说。我们把得到的第一个乘以2后大于 M的结果记为M~2~。同样，我们把已有的每个丑数乘以3和5，能得到第一 个大于M的结果M~3~和M~5~。那么下一个丑数应该是M~2~、M~3~和M~5~这3个数 的最小者。

   在前面分析的时候提到把己有的每个丑数分别乘以2、3和5。事实上 这不是必需的，因为已有的丑数是按顺序存放在数组中的。对于乘以2而 言，肯定存在某一个丑数T~2~，排在它之前的每个丑数乘以2得到的结果都 会小于已有最大的丑数，在它之后的每个丑数乘以2得到的结果都会太大。 我们只需记下这个丑数的位置，同时每次生成新的丑数的时候去更新这个 T~2~即可。对于乘以3和5而言，也存在同样的T~3~和T~5~。

  和第一种思路相比，第二种思路不需要在非丑数的整数上进行任何计 算，因此时间效率有明显提升。但也需要指出，第二种算法由于需要保存 已经生成的丑数，则因此需要一个数组，从而增加了空间消耗。如果是求 第1500个丑数，则将创建一个能容纳1500个丑数的数组，这个数组占据 6KB的内容空间。而第一种思路没有这样的内存开销。总的来说，第二种 思路相当于用较小的空间消耗换取了时间效率的提升。

**本题考点**

- 考查应聘者对时间复杂度的理解。绝大部分应聘者都能想出第一种 思路。在面试官提示还有更快的解法之后，应聘者能否分析出时间 效率的瓶颈，并找出解决方案，是能否通过这轮面试的关键。
- 考查应聘者的学习能力和沟通能力。丑数对很多人而言是一个新概 念。有些面试官喜欢在面试的时候定义一个新概念，然后针对这个 新概念出面试题。这就要求应聘者听到不熟悉的概念之后，要有主 动积极的态度，大胆向面试官提问，经过几次思考、提问、再思考 的循环，在短时间内理解这个新概念。这个过程就体现了应聘者的 学习能力和沟通能力。

### 面试题50：第一个只出现一次的字符

> 题目一：字符串中第一个只出现一次的字符。
>
>  在字符串中找出第一个只出现一次的字符。如输入"abaccdeff"，则输出'b'。

看到这道题时，我们最直观的想法是从头开始扫描这个字符串中的每 个字符。当访问到某字符时，拿这个字符和后面的每个字符相比较，如果 在后面没有发现重复的字符，则该字符就是只出现一次的字符。如果字符 串有n个字符，则每个字符可能与后面的O(n)个字符相比较，因此这种思 路的时间复杂度是O(n^2^)。面试官不会满意这种思路，他会提示我们还有更 快的方法。

由于题目与字符出现的次数相关，那么我们是不是可以统计每个字符在该字符串中出现的次数？要达到这个目的，我们需要一个数据容器来存 放每个字符的出现次数。在这个数据容器中，可以根据字符来査找它出现 的次数，也就是说这个容器的作用是把一个字符映射成一个数字。在常用 的数据容器中，哈希表正是这个用途。 为了解决这个问题，我们可以定义哈希表的键值(Key)是字符，而值 (Value)是该字符出现的次数。同时我们还需要从头开始扫描字符串两次。 第一次扫描字符串时，每扫描到一个字符，就在哈希表的对应项中把次数 加1。接下来第二次扫描时，每扫描到一个字符，就能从哈希表中得到该字 符出现的次数。这样，第一个只出现一次的字符就是符合要求的输出。

 哈希表是一种比较复杂的数据结构，C++标准模板库中的map和 unordered_map实现了哈希表的功能，我们可以直接拿过来用。由于本题的 特殊性，我们其实只需要一个非常简单的哈希表就能满足要求，因此我们 可以考虑实现一个简单的哈希表。字符(char)是一个长度为8的数据类型， 因此总共有256种可能。于是我们创建一个长度为256的数组，每个字母 根据其ASCII码值作为数组的下标对应数组的一个数字，而数组中存储的 是每个字符出现的次数。这样我们就创建了一个大小为256、以字符ASCII 码为键值的哈希表。 第一次扫描时，在哈希表中更新一个字符出现的次数的时间是O(1)。 如果字符串长度为n，那么第一次扫描的时间复杂度是O(n)。第二次扫描时， 同样在O(1)时间内能读出一个字符出现的次数，所以时间复杂度仍然是 O(n)。这样算起来，总的时间复杂度是O(n)。同时，我们需要一个包含256 个字符的辅助数组，它的大小是1KB。由于这个数组的大小是一个常数， 因此可以认为这种算法的空间复杂度是0(1).

**本题考点**

- 考查应聘者对数组和字符串的编程能力。
- 考查应聘者对哈希表的理解及运用。
- 考查应聘者对时间效率及空间效率的分析能力。当面试官提示最直观的算法不是最优解的时候，应聘者需要立即分析出这种算法的时 间效率。在想出基于哈希表的算法之后，应聘者也应该分析出该方 法的时间效率和空间效率分别是0(n)和0(1)。

**本题扩展**

在前面的例子中，我们之所以可以把哈希表的大小设为256，是因为字 符(char)是8bit的类型，总共只有256个字符。但实际上字符不只是256个，比如中文有几千个汉字。如果题目要求考虑汉字，那么前面的算法是不是有问题？那么应该怎么解决？

**相关题目：**

- 定义一个函数，输入两个字符串，从第一个字符串中刪除在第二个 字符串中出现过的所有字符。例如，从第一个字符串"We are  students."中删除在第二个字符串"aeiou"中出现过的字符得到的结 果是"W r Stdnts.".为了解决这个问题，我们可以创建一个用数组 实现的简单哈希表来存储第二个字符串。这样我们从头到尾扫描第 一个字符串的每个字符时，用O(1)时间就能判断出该字符是不是 在第二个字符串中。如果第一个字符串的长度是n，那么总的时间 复杂度是O(n)。
- 定义一个函数，删除字符串中所有重复出现的字符。例如，输入"google"，刪除重复的字符之后的结果是"gole"。这道题目和上面的 问题比较类似，我们可以创建一个用布尔型数组实现的简単的哈希 表。数组中的元素的意义是其下标看作ASCII码后对应的字母在 字符串中是否己经出现。我们先把数组中所有的元素都设为false。 以"google"为例，当扫描到第一个g时，g的ASCII码是103，那 么我们把数组中下标为103的元素设为true。当扫描到第二个g时， 我们发现数组中下标为103的元素的值是true.就知道g在前面巳 经出现过。也就是说，我们用O(1)时间就能判断出每个字符是否 在前面已经出现过。如果字符串的长度是n，那么总的时间复杂度 是O(n)。
- 在英语中，如果两个単词中出现的字母相同，并且每个字母出现的 次数也相同，那么这两个单词互为变位词(Anagram)。例如,silent 与listen, evil与live等互为变位词。请完成一个函数，判断输入 的两个字符串是不是为变位词。我们可以创建一个用数组实现的 简单哈希表，用来统计字符串中每个字符出现的次数。当扫描到第 一个字符串中的每个字符时，为哈希表对应的项的值增加1。接下 来扫描第二个字符。当扫描到每个字符时，为哈希表对应的项的 值减去1。如果扫描完第二个字符串后，哈希表中所有的值都是0， 那么这两个字符串就互为变位词。

**举一反三**

> 如果需要判断多个字符是不是在某个字符串里出现过或者统计多个字 符在某个字符串中出现的次数，那么我们可以考虑基于数组创建一个简单的哈希表，这样可以用很小的空间消耗换来时间效率的提升

> 题目二：字符流中第一个只出现一次的字符.
>
> 请实现一个函数，用来找出字符流中第一个只出现一次的字符。例 如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是'g'；当从该字符流中读出前6个字符"google"时，第一个只出现一次的字符'l'。

 字符只能一个接着一个从字符流中读出来。可以定义一个数据容器来 保存字符在字符流中的位置。当一个字符第一次从字符流中读出来时，把 它在字符流中的位置保存到数据容器里。当这个字符再次从字符流中读出 来时，那么它就不是只出现一次的字符，也就可以被忽略了。这时把它在 数据容器里保存的值更新成一个特殊的值(如负数值)。

 为了尽可能高效地解决这个问题。需要在O(1)时间内往数据容器里插 入一个字符，以及更新一个字符对应的值。受面试题50的启发，这个数据 容器可以用哈希表来实现。用字符的ASCII码作为哈希表的键值，而把字 符对应的位置作为哈希表的值。

**本题考点**

- 考查应聘者对数组和字符串的编程能力。
- 考查应聘者对哈希表的理解及运用。
-  考查应聘者对时间效率及空间效率的分析能力。当面试官提示最直 观的算法不是最优解的时候，应聘者需要立即分析出这种算法的时 间效率。在想出基于哈希表的算法之后，应聘者也应该分析出该方 法的时间效率和空间效率分别是O(n)和O(1)。

### 面试题51：数组中的逆序对

> 题目：在数组中的两个数字，如果前面一个数字大于后面的数字， 则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序 对的总数。例如，在数组{7,5,6,4}中，一共存在5个逆序对，分别是(7,6)、 (7,5)、(7,4)、(6,4)和(5,4)。

看到这道题目，我们的第一反应是顺序扫描整个数组。每扫描到一个 数字，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小， 则这两个数字就组成一个逆序对。假设数组中含有n个数字。由于每个数 字都要和O(n)个数字进行比较，因此这种算法的时间复杂度是O(n^2^)。我们 再尝试找找更快的算法。

 我们以数组{7, 5, 6, 4}为例来分析统计逆序对的过程。每扫描到一个数 字的时候，我们不能拿它和后面的每一个数字进行比较。否则时间复杂度 就是O(n^2^)，因此，我们可以考虑先比较两个相邻的数字。

我们可以总结出统计逆序对的过程：先把数组 分隔成子数组，统计出子数组内部的逆序对的数目，然后再统计出两个相 邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进 行排序。如果对排序算法很熟悉，那么我们不难发现这个排序的过程实际 上就是归并排序。

我们知道，归并排序的时间复杂度是$O(nlogn)$，比最直观的O(n^2^)要快， 但同时归并排序需要一个长度为n的辅助数组，相当于我们用的空间 消耗换来了时间效率的提升，因此这是一种用空间换时间的算法。

**本题考点：** 

- 考查应聘者分析复杂问题的能力。统计逆序对的过程很复杂，如何 发现逆序对的规律，是应聘者解决这道题目的关键。
- 考查应聘者对归并排序的掌握程度。如果应聘者在分析统计逆序对 的过程中发现问题与归并排序的相似性，并能基于归并排序形成解 题思路，那通过这轮面试的概率就很大了。

### 面试题52：两个链表的第一个公共节点

> 题目：输入两个链表，找出它们的第一个公共节点。链表节点定义如下：

面试的时候碰到这道题，很多应聘者的第一反应就是蛮力法：在第一 链表上顺序遍历每个节点，每遍历到一个节点，就在第二个链表上顺序遍 历每个节点。如果在第二个链表上有一个节点和第一个链表上的节点一样， 则说明两个链表在这个节点上重合，于是就找到了它们的公共节点。如果 第一个链表上的长度为m，第二个链表的长度为n，那么，显然该方法的时间 复杂度是O(mn)。

 通常蛮力法不会是最好的办法，我们接下来试着分析有公共节点的两 个链表有哪些特点。从链表节点的定义诃以看出，这两个链表是单向链表。 如果两个単向链表有公共的节点，那么这两个链表从某一节点开始，它们 的m_pNext都指向同一个节点。但由于是单向链表的节点，每个节点只有 一个m_pNext。因此从第一个公共书点开始，之后它们所有的节点都是重 合的，不可能再出现分叉。所以两个有公共节点而部分重合的链表，其拓 扑形状看起来像一个Y，而不可能像X。

经过分析我们发现，如果两个链表有公共节点，那么公共节点出现在 两个链表的尾部。如果我们从两个链表的尾部开始往前比较，那么最后一 个相同的节点就是我们要找的节点。可问题是，在单向链表中，我们只能从 头节点开始按顺序遍历，最后才能到达尾节点。最后到达的尾节点却要最先 被比较，这听起来是不是像“后进先出”？于是我们就能想到用栈的特点来解决这个问题：分别把两个链表的节点放入两个栈里，这样两个链表的尾节 点就位于两个栈的栈顶，接下来比较两个栈顶的节点是否相同。如果相同， 则把栈顶弹岀接着比较下一个栈顶，直到找到最后一个相同的节点。 

在上述思路中，我们需要用两个辅助栈。如果链表的长度分别为m和n， 那么空间复杂度是O(m+n)。这种思路的时间复杂度也是O(m+n)。和最开始 的蛮力法相比，时间效率得到了提高，相当于用空间消耗换取了时间效率。

 之所以需要用到栈，是因为我们想同时遍历到达两个栈的尾节点。当 两个链表的长度不相同时，如果我们从头开始遍历，那么到达尾节点的 时间就不一致。其实解决这个问题还有一种更简单的办法：首先遍历两个链 表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多 几个节点。在第二次遍历的时候，在较长的链表上先走若干步，接着同时在 两个链表上遍历，找到的第一个相同的节点就是它们的第一个公共节点。

第三种思路和第二种思路相比，时间复杂度都是O(m+n)，但我们不再 需要辅助栈，因此提高了空间效率。

**本题考点：**

- 考查应聘者对时间复杂度和空间复杂度的理解及分析能力。解决这道题有多种不同的思路。每当应聘者想到一种思路的时候，都要很快分析出这种思路的时间复杂度和空间复杂度各是多少，并找到可以优化的地方。
- 考查应聘者对链表的编程能力。

**相关题目：**

如果把图5.4逆时针旋转90°，我们就会发现两个链表的拓扑形状和 一棵树的形状非常相似，只是这里的指针是从叶节点指向根节点的。两个 链表的第一个公共节点正好就是二叉树中两个叶节点的最低公共祖先。在 本书7.2节，我们将详细讨论如何求两个节点的最低公共祖先。

## 本章小结

在编程面试的时候，而试官通常对时间复杂度和空间夏杂度都会有要 求，并且一般情况下面试官更加关注时间复杂度。 

降低时间复杂度的第一种方法是改用更加高效的算法。比如我们用动 态规划解答面试题42 “连续子数组的最大和”能够把时间复杂度降低到 O(n)，利用快速排序的Partition函数也能在O(n)时间内解决面试题39 “数 组中出现次数超过一半的数字”和面试题40 “最小的k个数”。

 降低时间复杂度的第二种方法是用空间换取时间。在解决面试题50“第 一个只出现一次的字符”的时候。我们用数组实现一个简単的哈希表。于 是用O(1)时间就能知道任意字符出现的次数。这种思路可以解决很多同类 型的题目。另外，我们可以创建一个缓存保存中间的计算结果，从而避免 重复的计算。面试题49“丑数”就是这方面的一个例子，在用递归的思路 求解问题的时候，如果有重复的子问题，那么我们也诃以通过保存求解于 问题的结果来避免重复计算。

值得注意的是，以空间换取时间并不一定都是可行的方案。我们要注 意需要的辅助空间的大小，消耗太多的内存可能得不偿失。另外，我们还 要关注问题的背景。如果面试题是有关嵌入式开发的。那么对空间消耗就 要格外留心，因为通常嵌入式系统的内存很有限。

































































