# 面试中的各项能力

## 沟通能力和学习能力

1. 沟通能力

   随着软件、系统功能越来越复杂，开发团队的规模也随之扩张，开发 者、测试者和项目经理之间的沟通交流也变得越来越重要。也正因如此， 很多公司在面试的时候都会注意考査应聘者的沟通能力。这就要求应聘者无论是在介绍项目经验还是在介绍解题思路的时候，都需要逻辑清晰明了，语言详略得当，表述得时候重点突出、观点明确。

2. 学习能力

   计算机是一门更新速度很快的学科，每年都有新的技术不断涌现。因 此，作为这个领域从业人员的软件工程师需要具备很强的学习能力，否则 时间一长就会跟不上技术进步的步伐。也正是因为这个原因，IT公司在面 试的时候，面试官都会重视考查应聘者的学习能力。只有具备很强的学习 能力及学习愿望的人，才能不断完善自己的知识结构，不断学习新的先进 技术，让自己的职业生涯保持长久的生命力。 通常面试官有两种方法考查应聘者的学习能力。第一种方法是询问应 聘者最近在看什么书或者在做什么项目、从中学到了哪些新技术。面试官 可以用这个问题了解应聘者的学习愿望和学习能力。学习能力强的人对各 种新技术充满了兴趣，随时学习、吸收新知识，并把知识转换为自己的技 能。第二种方法是抛出一个新概念，接下来观察应聘者能不能在较短时间 内理解这个新概念并解决相关的问题。本书收集的面试题涉及诸如数组的 旋转（面试题11）、二叉树的镜像（面试题27）、丑数（面试题49）、逆序 对（面试题51）等新概念。当面试官提出这些新概念的时候，他期待应聘 者能够通过思考、提向、再思考的过程，理解它们并最终解决问题。

3. 善于学习、沟通的人也善于提问

   面试官有一个很重要的任务，就是考查应聘者的学习愿望及学习能力。 学习能力怎么体现呢？面试官提出一个新概念，应聘者没有听说过它，于 是他在已有的理解的基础上提出进一步的问题，在得到面试官的答复之后， 思考再提问。几个来回之后掌握了这个概念。这个过程能够体现应聘者的 学习能力。通常学习能力强的人具有主动积极的态度，对未知的领域有强 烈的求知欲望。因此，建议应聘者在面试过程中遇到不明白的地方多提问， 这样面试官就会觉得你态度积极、求知欲望强烈，会给面试结果加分。

**面试小提示**

> 面试是一个双向交流的过程，面试官可以问应聘者问题，同样应聘者 也可以向面试官提问。如果应聘者能够针对面试题主动地提出几个高质量 的问题，那么而试官就会觉得他有很强的沟通能力和学习能力。

有些面试官故意一开始不把题目描述清楚，让题目存在一定的二义性。 他期待应聘者能够一步歩通过提问来弄明白题目的要求。这也是在考査应 聘者的沟通能力。为什么要这样考査？因为实际工作也是这样，不是一开 始项目需求就定义得很清楚，程序员需要与项目经理甚至客户反复沟通才 能把需求弄清楚。如果没有一定的沟通能力，那么当程序员面对一个模糊 的客户需求时，他就会觉得无从下手。

## 知识迁移能力

所谓学习能力，很重要的一点就是根据已经掌握的知识、技术，能够 迅速学习、理解新的技术并运用到实际工作中去。大部分新的技术都不是 凭空产生的，而是在已有技术的基础上发展起来的。这就要求我们能够把 对已有技术的理解迁移到学习新技术的过程中去，也就是要具备很强的知 识迁移能力。以学习编程语言为例，如果全面理解了 C++的面向对象的思 想，那么学习下一门面向对象的语言Java就不会很难；在深刻理解了Java 的垃圾回收机制之后，再去学习另一门托管语言比如C#，也会很容易。

面试官考查应聘者知识迁移能力的一种方法是把经典的问题稍作变 换。这时候面试官期待应聘者能够找到和经典问题的联系，并从中受到启发，把解决经典问题的思路迁移过来解决新的问题。

面试官考查应聘者知识迁移能力的另一种方法就是先问一个简单的问 题，在应聘者解答完这个简单的问题之后，再追问一个相关的同时难度也 更大的问题。这时候面试官希望应聘者能够总结前面解决简单问题的经验， 把前面的思路、方法迁移过来。

知识迁移能力的一种通俗的说法是“举一反三”的能力。我们在去面 试之前，通常都会看一些经典的面试题。然而题目总是做不完的，我们不 可能把所有的面试题都准备一遍。因此，更重要的是每做一道面试题的时 候，都要总结这道题的解法有什么特点，有哪些思路是可以应用到同类型 的题目中去的。

### 面试题53：在排序数组中查找数字

>题目一：数字在排序数组中出现的次数。
>
>统计一个数字在排序数组中出现的次数。例如，输入排序树组{1, 2, 3, 3, 3, 3, 4, 5}和数字3，由于3在这个数组中出现了4次，因此输出4。

既然输入的数组是排序的，那么我们就能很自然地想到用二分查找算 法。在题目给出的例子中，我们可以先用二分查找算法找到一个3。由于3 可能出现多次，因此我们找到的3的左右两边可能都有3，于是在找到的3 的左右两边顺序扫描，分别找出第一个3和最后一个3。因为要查找的数字 在长度为n的数组中有可能出现O(n)次，所以顺序扫描的时间复杂度是 O(n)。因此，这种算法的效率和直接从头到尾顺序扫描整个数组统计3出现 的次数的方法是一样的。显然，面试官不会满意这个算法，他会提示我们 还有更快的算法。

 接下来我们思考如何更好地利用二分查找算法。假设我们要统计数字k 在排序数组中出现的次数。在前面的算法中，时间主要消耗在如何确定重 复出现的数字的第一个k和最后一个k的位置上，有没有可能用二分查找算 法直接找到第一个k及最后一个k呢？

 我们先分析如何用二分查找算法在数组中找到第一个k。二分查找算法 总是先拿数组中间的数字和k作比较。如果中间的数字比k大，那么k只 有可能出现在数组的前半段，下一轮我们只在数组的前半段査找就可以 了。如果中间的数字比k小，那么k只有可能出现在数组的后半段，下一 轮我们只在数组的后半段査找就可以了。如果中间的数字和k相等呢？我 们先判断这个数字是不是第一个k。如果中间数字的前面一个数字不是k，那么此时中间的数字刚好就是第一个k。如果中间数字的前面一个数字也是 k，那么第一个k肯定在数组的前半段，下一轮我们仍然需要在数组的前半 段查找。

> 题目二：0\~n-1中缺失的数字。
>
> 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个 数字都在范围0\~n-1之内。在范围0\~n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

这个问题有一个直观的解决方案。我们可以先用公式$n(n-1)/2$求出数 字0\~n-1的所有数字之和，记为$s_1$。接着求出数组中所有数字的和，记为$s_2$。那个不在数组中的数字就是$s_1-s_2$的差。这种解法需要O(n)的时间 求数组中所有数字的和。显然，该解法没有有效利用数组是递増排序的这 —特点。

因为0\~n-1这些数字在数组中是排序的，因此数组中开始的一些数字 与它们的下标相同。也就是说，0在下标为0的位置，1在小标为1的位置， 以此类推。如果不在数组中的那个数字记为m，那么所有比m小的数字的 下标都与它们的值相同。

由于m不在数组中，那么m+1处在下标为m的位置，m+2处在下标为m+1 的位置，以此类推。我们发现m正好是数组中第一个数值和下标不相 等的下标，因此这个问题转换成在排序数组中找出第一个值和下标不相等 的元素。

我们可以基于二分查找的算法用如下过程查找：如果中间元素的值和 下标相等，那么下一轮查找只需要查找右半边；如果中间元素的值和下标 不相等，并且它前面一个元素和它的下标相等，这意味若这个中间的数字 正好是第一个值和下标不相等的元素，它的下标就是在数组中不存在的数 字；如果中间元素的值和下标不相等，并且它前面一个元素和它的下标不 相等，这意味着下一轮查找我们只需要在左半边查找即可。

> 题目三：数组中数值和下标相等的元素。
>
> 假设一个单调递増的数组里的每个元素都是整数并且是唯一的。请编 程实现一个函数，找出数组中任意一个数值等于其下标的元素。例如，在 数组{-3,-1,1,3,5}中，数字3和它的下标相等。 

我们很容易就能想到最直观的解法：从头到尾依次扫描数组中的数字， 并逐一检验数字是不是和下标相等。显然,这种算法的时间复杂度是O(n)。

 由于数组是单调递増排序的，因此我们可以尝试用二分査找算法来进 行优化。假设我们某一步抵达数组中的第i个数字。如果我们很幸运，该数 字的值刚好也是i，那么我们就找到了一个数字和其下标相等。

那么当数字的值和下标不相等的时候该怎么办呢？假设数字的值为m。 我们先考虑m大于i的情形，即数字的值大于它的下标。由于数组中的所 有数字都唯一并且单调递増，那么对于任意大于0的k,位于下标i+k的数 字的值大于或等于m+k。另外，因为m>i，所以m+k>i+k。因此，位于下标 i+k的数字的值一定大于它的下标。这意味着如果第i个数字的值大于i，那 么它右边的数字都大于对应的下标，我们都可以忽略。下一轮査找我们只 需要从它左边的数字中査找即可。

 数字的值m小于它的下标i的情形和上面类似。它左边的所有数字的 值都小于对应的下标，我们也可以忽略。感兴趣的读者请自己证明。 由于我们在毎一步査找时都可以把査找的范围缩小一半，这是典型的 二分査找的过程。

**本题考点：**

- 考查应聘者的知识迁移能力。我们都知道，二分査找算法可以用来 在排序数组中査找一个数字。应聘者如果能够运用知识迁移能力， 把问题转换成用二分査找算法在排序数组中査找某些特定的数字， 那么这些问题也就解决了一大半。
- 考查应聘者对二分査找算法的理解程度，这道题实际上是二分査找 算法的加强版。只有对二分查找算法有着深刻的理解，应聘者才有 可能解决这个问题。

面试题54：二叉搜索树的第k大节点

> 题目：给定一棵二叉搜索树，请找出其中第k大的节点。

这道题实质上考查应聘者对中序遍历的理解。

**本题考点：**

- 考查应聘者的知识迁移能力。面试官期待应聘者能够运用中序遍历 算法来解决这道面试题。 
-  考查应聘者对二叉搜索树和中序遍历的特点的理解。如果应聘者理解二叉搜索树的中序遍历序列是递増的，那么就很容易就能找出第k大的节点。

### 面试题55：二叉树深度

> 题目一：二叉树的深度。
>
> 输入一颗二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根，叶子结点）形成树的一条路径，最长路径的长度为树的深度。



> 题目二：平衡二叉树。
>
> 输入一棵二叉树的根节点，判断该树是不是平衡二叉树，如果某二叉 树中任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

- 需要重复遍历节点多次的解法，简单但不足以打动面试官

   有了求二叉树的深度的经验之后再解决这个问题，我们很容易就能想 到一种思路：在遍历树的每个节点的时候，调用函数TreeDepth得到它的左、 右了树的深度。如果每个节点的左、右了树的深度相差都不超过1，那么按 照定义它就是一棵平衡二叉树。

  上面的代码固然简洁，但我们也要注意到由于一个节点会被重复遍历 多次，这种思路的时间效率不高。

- 每个节点只遍历一次的解法，正是面试官喜欢的

  如果我们用后序遍历的方式遍历二叉树的每个节点，那么在遍历到一 个节点之前我们就已经遍历了它的左、右子树。只要在遍历每个节点的时候 记录它的深度(某一节点的深度等于它到叶节点的路径的长度)，我们就可以 一边遍历一边判断每个节点是不是平衡的。

  在上面的代码中，我们用后序遍历的方式遍历整棵二叉树。在遍历某 节点的左、右子节点之后，我们可以根据它的左、右子节点的深度判断它 是不是平衡的，并得到当前节点的深度。当最后遍历到树的根节点的时候， 也就判断了整棵二叉树是不是平衡二叉树。

**本题考点**

- 考查应聘者对二叉树的理解及编程能力。这两道题的解法实际上只 是树的遍历算法的应用。
- 考查应聘者对新概念的学习能力。面试官提出一个新的概念即树的 深度，这就要求我们在较短的时间内理解这个概念并解决相关的问 题。这是一种常见的面试题型。能在较短时间内掌握、理解新概念 的能力就是一种学习能力。
- 考查应聘者的知识迁移能力。如果面试官先问如何求二叉树的深 度，再问如何判断一棵二叉树是不是平衡的，那么应聘者应该从 求二叉树深度的分析过程中得到启发，找到判断平衡二叉树的突 破口。

### 面试题56：数组中数字出现的次数 

> 题目一：数组中只出现一次的两个数字。
>
> 一个整形数组里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

这是一道比较难的题目，很少有人能在面试的时候不需要提示一下子想到最好的解决方法。一般当应聘者想了几分钟后还没有思路，面试官会给出一些提示。面试官很有可能会说：你可以先考虑这个数组中只有一个 数字只出现了一次，其他数字都出现了两次，怎么找出这个数字？

这两道题目都在强调一个（或两个）数字只出现一次，其他数字出现 两次。这有什么意义呢？我们想到异或运算的一个性质：任何一个数字异 或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每个数 字，那么最终的结果刚好是那个只出现一次的数字，因为那些成对出现两 次的数字全部在异或中抵消了。

想明白怎么解决这个简单的问题之后，我们再回到原始的问题，看看 能不能运用相同的思路。我们试着把原数组分成两个子数组，使得每个子 数组包含一个只出现一次的数字，而其他数字都成对出现两次。如果能够 这样拆分成两个数组。那么我们就可以按照前面的办法分别找出两个只出 现一次的数字了。

我们还是从头到尾依次异或数组中的每个数字，那么最终得到的结果 就是两个只出现一次的数字的异或结果，因为其他数字都出现了两次，在 异或中全部抵消了。由于这两个数字肯定不一样，那么异或的结果肯定不 为0，也就是说，在这个结果数字的二进制表示中至少有一位为1。我们在 结果数字中找到第一个为1的位的位置，记为第n位。现在我们以第n位 是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每个 数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。由于我 们分组的标准是数字中的某一位是1还是0，那么出现了两次的数字肯定被 分配到同一个子数组。因为两个相同的数字的任意一位都是相同的，我们 不可能把两个相同的数字分配到两个子数組中去，于是我们已经把原数组 分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其他数 字都出现了两次。我们己经知道如何在数组中找出唯一一个只出现一次的 数字，因此，到此为止所有的问题都己经解决了。

> 题目二：数组中唯一只出现一次的数字。
>
> 在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只岀现一次的数字。

如果我们把题目稍微改一改，那么就会容易很多：如果数组中的数字 除一个只出现一次之外，其他数字都出现了两次。我们可以用XOR异或位 运算解决这个简化的问题。由于两个相同的数字的异或结果是0，我们把数 组中所有数字异或的结果就是那个唯一只出现一次的数字。

 可惜这种思路不能解决这里的问题，因为三个相同的数字的异或结果 还是该数字。尽管我们这里不能应用异或运算。我们还是可以沿用位运算 的思路。如果一个数字出现三次，那么它的二进制表示的每一位（0或者1） 也出现三次。如果把所有出现三次的数字的二进制表示的每一位都分别加 起来，那么每一位的和都能被3整除。

我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被3整除，那么那个只出现一次的数字二进制表示中对应的那一位是0；否则就是1。

这种解法的时间效率是O(n)。我们需要一个长度为32的辅助数组存储 二进制表示的每一位的和。由于数组的长度是固定的，因此空间效率是 O(1)。该解法比其他两种直观的解法效率都要高：（1）我们很容易就能从排 序的数组中找到只出现一次的数字，但排序需要O(nlogn)时间：（2）我们 也可以用一个哈希表来记录数组中每个数字出现的次数，但这个哈希表需 要O(n)的空间。

**本题考点：** 

- 考查应聘者的知识迁移能力。其他数字都出现两次而只有一个数字 出现一次这个简单的问题，很多应聘者都能想到解决办法。能不能 把解决简单问題的思路迁移到复杂问题上，继续从位运算上想办 法，是应聘者能否通过这轮面试的关键。 
- 考查应聘者对二进制和位运算的理解。

### 面试题57：和为s的数字

> 题目一：和为s的两个数字。
>
> 输入一个递増排序的数组和一个数字s，在数组中査找两个数，使得它们的和正好是s。如果有多对教字的和等于s，则输出任意一对即可。

在面试的时候，很重要的一点是应聘者要表现出很快的反应能力。只 要想到一种方法，应聘者就可以马上告诉面试官，即使这种方法不一定是 最好的。比如这个问题，很多人都能立即想到O(n^2^)的方法，也就是先在数 组中固定一个数字，再依次判断数组中其余的$n-1$个数字与它的和是不是 等于s。面试官会告诉我们这不是最好的办法。不过这没有关系，至少面试 官知道我们的思维还是比较敏捷的。

接着我们寻找更好的算法。我们先在数组中选择两个数字，如果它们 的和等于输入的s，那么我们就找到了要找的两个数字。如果和小于s呢？ 我们希望两个数字的和再大一点。由于数组已经排好序了，我们可以考虑 选择较小的数字后面的数字。因为排在后面的数字要大一些，那么两个数 字的和也要大一些，就有可能等于输入的数字s 了。同样，当两个数字的和 大于输入的数字的时候，我们可以选择较大数字前面的数字，因为排在数 组前面的数字要小一些。该算法的时间复杂度为O(n)。

> 题目二：和为s的连续正数序列。
>
> 输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如，输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以打印出3个连续序列1\~5，4\~6和7\~8。

有了解决前面问题的经验，我们也考虑用两个数small和big分别表示序列的最小值和最大值。首先把small初始化为1，big初始化为2。如果从 small到big的序列的和大于s，则可以从序列中去掉较小的值,也就是増大 small的值。如果从small到big的序列的和小于s,则可以増大big,让这 个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直増加 small 到(1+s)/2为止。

**本题考点：**

- 考查应聘者思考复杂问题的思维能力。应聘者如果能够通过一两个 具体的例子找到规律，那么解决这个问题就容易多了。 
- 考查应聘者的知识迁移能力。应聘者面对第二个问题的时候，能 不能把解决第一个问题的思路应用到新的题目上，是面试官考査查知识迁移能力的重要指标。

### 面试题58：翻转字符串

> 题目一：翻转单词顺序。
>
> 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student."，则输出"student. a am I"。

这道题目流传甚广，很多公司多次拿来作为面试题，很多应聘者也多 次在各种博客或者书籍上看到通过两次翻转字符串的解法，于是很快就可 以跟面试官解释清楚解题思路：第一步翻转句子中所有的字符。比如翻转 "I am a student."中所有的字符得到".tneduts a ma l",此时不但翻转了句子中 单词的顺序，连单词内的字符顺序也被翻转了。第二步再翻转每个单词中 字符的顺序，就得到了"student. a am l"。这正是符合题目要求的输出。

> 题目二：左旋转字符串
>
> 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部，请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果为"cdefgab"。

以"abcdefg"为例，我们可以把它分为两部分。由于想把它的前两个字 符移到后面，我们就把前两个字符分到第一部分，把后面的所有字符分到 第二部分。我们先分别翻转这两部分，于是就得到"bagfedc"。接下来翻转 整个字符串，得到的"cdefgab”刚好就是把原始字符串左旋转两位的结果。

想清楚思路之后再写代码是一件很容易的事情，但我们也不能掉以轻 心。面试官在检查与字符串相关的代码时经常会发现两种问题：一是输入 空指针nullptr时程序会崩溃；二是内存访问越界的问题，也就是试图访问 不属于字符串的内存。

**本题考点：**

- 考查应聘者的知识迁移能力。当面试的时候遇到第二个问题，而之 前我们做过“翻转句子中单词的顺序”这道题目，如果能够把多 次翻转字符串的思路迁移过来，就能很轻易地解决字符串左旋转 的问题。
- 考查应聘者对字符串的编程能力。

### 面试题59：队列的最大值

> 题目一：滑动窗口的最大值
>
> 给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为{4,4,6,6,6,5}

如果釆用蛮力法，那么这个问题似乎不难解决：可以扫描每个滑动窗口的所有数字并找出其中的最大值。如果滑动窗口的大小为k，则需要O(k)时间才能找出滑动窗口里的最大值。对于长度为n的输入数组，这种算法的总时间复杂度是O(nk)。

实际上，一个滑动窗口可以看成一个队列。当窗口滑动时，处于窗口 的第一个数字被删除，同时在窗口的末尾添加一个新的数字。这符合队列 的“先进先出”特性。如果能从队列中找出它的最大数，那么这个问题也 就解决了。

在面试题30中，我们实现了一个可以用O(1)时间得到最小值的栈。同 样，也可以用0(1)时间得到栈的最大值。同时在面试题9中，我们讨论了 如何用两个栈实现一个队列。综合这两个问题的解决方案，我们发现，如果 把队列用两个栈实现，由于可以用0(1)时间得到栈中的最大值，那么也就可 以用O(1)时间得到队列的最大值，因此总的时间复杂度也就降到了O(n)。

我们可以用这种方法来解决本题。不过这样就相当于在一轮面试的时 间内要做两道面试题，时间未必够用。再来看看有没有其他的方法。 下面换一种思路。我们并不把滑动窗口的每个数值都存入队列，而是 只把有可能成为滑动窗口最大值的数值存入一个两端开口的队列

> 题目二：队列的最大值
>
> 请定义一个队列并实现函数max得到队列里的最大值，要求函数max、push_back和pop_front的时间复杂度都是O(1)。

如前所述，滑动窗口可以看成一个队列，因此上题的解法可以用来实现带max函数的队列。

由于该解法和上题找滑动窗口的最大值类似。

**本题考点：**

- 考查应聘者分析问题的能力。无论是求滑动窗口的最大值还是求队 列的最大值，都不是一道容易的面试题，应聘者可以通过举例的方 法一步步分析，找出其中的规律。
- 考查应聘者的知识迁移能力。如果应聘者深入理解了滑动窗口最大 值和队列最大值之间的联系，那么掌握了上述两道题中任意一道题 的解法，就能顺利解答另外一道题。

## 抽象建模能力

建模的第一步是选择合理的数据结构来表述问题。实际生产生活中的 问题千变万化，而常用的数据结构只有有限的几种。我们在根据问题的特 点综合考虑性能、编程难度等因素之后，选择最合适的数据结构来表达问 题，也就是建立模型。比如在面试题61“扑克牌中的顺子”中，我们用一 个数组表示一副牌，用11、12和13分别表示J、Q、K，并且用0表示大 小王。在面试题62 “圆圈中最后剩下的数字”中。我们可以用一个环形链 表模拟一个圆圏。

建模的第二步是分析模型中的内在规律，并用编程语言表述这种规律。 我们只有对现实问题进行深入细致的观察分析之后，才能找到模型中的规 律，才有可能编程解决问题。例如，在本书2.4.1节提到的“青蛙跳台阶” 问题中，它内在的规律是斐波那契数列。再比如面试题60“n个骰子的点 数”问题，其本质是求数列$f(n)=f(n-1)+f(n-2)+f(n-3)+f(n-4)+f(n-5)+f(n-6)$。 找到这个规律之后，我们就可以分别用递归和循环两种不同的方法去写代 码。然而，并不是所有问题的内在规律都是显而易见的。在面试题62“圆圈中最后剩下的数字”中，我们经过严密的数学分析之后才能找到每次从 圆圈中删除数字的规律，从而找到一种不需要辅助环形链表的快速方法来 解决问题。

### 面试题60: n个骰子的点数

> 题目：把n个骰子投在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

骰子一共有6个面，每个面上都有一个点数，对应的是1\~6之间的一个数字。所以n个骰子的点数和的最小值为n，最 大值为6n。另外，根据排列组合的知识，我们还知道n个骰子的所有点数 的排列数为6^n^。要解决这个问题，我们需要先统计出每个点数出现的次数， 然后把每个点数出现的次数除以6^n^，就能求出每个点数出现的概率。

- 解法一：基于递归求骰子点数，时间效率不够高

现在我们考虑如何统计每个点数出现的次数。要想求出n个骰子的点 数和，可以先把n个骰子分为两堆：第一堆只有一个：另一堆有n-1个。 単独的那一个有可能出现1\~6的点数。我们需要计算1\~6的每一种点数 和剩下的n\~1个骰子来计算点数和。接下来把剩下的n-1个骰子仍然分成 两堆：第一堆只有一个；第二堆有n-2个。我们把上一轮那个单独骰子的 点数和这一轮单独骰子的点数相加，再和剩下的n\~2个骰子来计算点数和。 分析到这里，我们不难发现这是一种递归的思路，递归结束的条件就是最 后只剩下一个骰子。

 我们可以定义一个长度为$6n-n+1$的数组，将和为s的点数出现的次数 保存到数组的第s-n个元素里。

- 解法二：基于循环求骰子点数，时间性能好

可以换一种思路来解决这个问题。我们可以考虑用两个数组来存储骰 子点数的每个总数出现的次数。在一轮循环中，第一个数组中的第n个数 字表示骰子和为n出现的次数。在下一轮循环中，我们加上一个新的骰子， 此时和为n的骰子出现的次数应该等于上一轮循环中骰子点数和为n-1、n-2、n-3、n-4、n-5与n-6的次数的总和，所以我们把另一个数组的第n 个数字设为前一个数组对应的第n-1、n-2、n-3、n-4、n-5与 n-6个数字 之和。

**本题考点：**

- 考查应聘者的数学建模能力。不管采用哪种思路解决问题，我们都要先想到用数组来存放n个骰子的每个点数出现的次数，并通过分析点数的规律建立模型，最终找到解决方案。
- 考查应聘者对递归和循环的性能的理解。

### 面试题61：扑克牌中的顺子

> 题目：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌 是不是连续的。2\~10为数字本身，A为1， J为11，Q为12, K为13，而大、小王可以看成任意数字。



我们需要把扑克牌的背景抽象成计算机语言，不难想象，我们可以把5张牌看成由5个数字组成的数组。大小王是特殊的数字，我们不妨把它们都定义为0，这样就能和其他扑克牌区分开来了。

接下来我们分析怎样判断5个数字是不是连续的，最直观的方法是把 数组排序。值得注意的是，由于0可以当成任意数字，我们可以用0去补 满数组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相 隔若干个数字，那么只要我们有足够的0可以补满这两个数字的空缺，这 个数组实际上还是连续的。举个例子，数组排序之后为{0,1,3,4,5},在I和 3之间空缺了一个2，刚好我们有一个0。也就是我们可以把它当成2去填 补这个空缺。

于是我们需要做3件事情：首先把数组推序；其次统计数组中0的个 数；最后统计排序之后的数组中相邻数字之间的空缺总数。如果空缺的总 数小于或者等于0的个数，那么这个数组就是连续的；反之则不连续。

 最后我们还需要注意一点：如果数组中的非0数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是：如果一副牌里含有对子，则不可能是顺子。

**本题考点：**

考查应聘者的抽象建模能力。这道题目要求我们把熟悉的扑克牌转换 为数组，把找顺子的过程通过排序、计数等步骤实现。这些都是把生活中 的模型用程序语言来表达的例子。

### 面试题62：圆圏中最后剰下的数字

> 题目：0，1，……，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

本题就是有名的约瑟夫环问题。这里将介绍两种解法：

一种方法是用环形链表模拟圆圈的经典解法；第二种方法是分析毎次被删 除的数字的规律并直接计算出圖圈中最后剩下的数字. 

- 经典的解法，用环形链表模拟圆圈

 既然题目中有一个数字圆圈，很自然的想法就是用一个数据结构来模 拟这个圆圈。在常用的数据结构中，我们很容易想到环形链表。我们可以创 建一个共有n个节点的环形链表，然后每次在这个链表中删除第m个节点。

 如果面试官要求我们不能使用标准模板库里的数据容器来模拟环形链 表，那么我们自己实现一个链表也不是很难的事情。如果面试官没有特殊 要求，那么可以用模板库中的std::list来模拟一个环形链表。由于std::list 本身并不是一个环形结构，因此每当迭代器(Iterator)扫描到链表末尾的 时候，我们要记得把迭代器移到链表的头部，这样就相当于按照顺序在一 个圆圈里遍历了。

如果我们用一两个例子仔细分析上述代码的运行过程，就会发现，实 际上需要在环形链表里重复遍历很多遍。重复的遍历当然对时间效率有负 面的影响。这种方法每删除一个数字需要m步运算，共有n个数字，因此 总的时间复杂度是O(mn)。同时这种思路还需要一个辅助链表来模拟圖圏， 其空间复杂度是O(n)。接下来我们试着找到每次被删除的数字有哪些规律。 希望能够找到更加高效的算法。

- 创新的解法，拿到Offer不在话下

首先我们定义一个关于n和m的方程$f(n,m)$表示每次在n个数字$0,1,\cdots ,n-1$中删除第m个数字最后剩下的数字。

 在这n个数字中，第一个被删除的数字是$(m-1)\%n$。为了简单起见，我 们把$(m-1)\%n$记为k，那么删除k之后剩下的n-1个数字为 $0,1,\cdots,k-1,k+1,\cdots,n-1$，并且下一次删除从数字k+1开始计数。相当于在剩 下的序列中，排在最前面，从而形成$k+1,\cdots,n-1,0,1,\cdots,k-1$。该序列最 后剩下的数字也应该是关于n和m的函数。由于这个序列的规律和前面最 初的序列不一样（最初的序列是从0开始的连续序列），因此该函数不同于 前面的函数，记为$f(n-1,m)$。最初序列最后剩下的数字$f(n,m)$一定是删除 一个数字之后的序列最后剩下的数字，即$f(n,m)=f(n-1,m)$ 。

接下来我们把剩下的这n-1个数字的序列$k+1,\cdots,n-1,0,1,\cdots,k-1$进行映 射，映射的结果是形成一个0\~n-2的序列。

我们把映射定义为p，则$p(x)=(x-k-1)\%n$。它表示如果映射前的数字是x，那么映射后的数字是$(x-k-1)\%n$。该映射的逆映射是$p^{-1}(x)=(x+k+l)\%n$。 

由于映射之后的序列和最初的序列具有同样的形式，即都是从0开始 的连续序列，因此仍然可以用函数f来表示，记为$f(n-1,m)$。根据我们的映 射规则，映射之前的序列中最后剩下的数字$f(n-1,m)=p^{-1}[f(n-1,m)]=[f(n-1,m)+k+1]\%n$。把$k=(m-1)\%n$代入得到$f(n,m)=f^{'}(n-1,m)=[f(n-1,m)+m]\%m$。

经过上面复杂的分析，我们终于找到了一个递归公式。要得到n个数 字的序列中最后剩下的数字，只需要得到n-1个数字的序列中最后剩下的 数字，并以此类推。当n=1时，也就是序列中开始只有一个数字0，那么很 显然最后剩下的数字就是0。我们把这种关系表示为：
$$
f(n,m)=
\begin{cases}
0 &n=1\\
\left[f(n-1,m)+m \right]\%n &n>1
\end{cases}
$$
这个公式无论是用递归还是循环，都很容易实现。

可以看出，这种思路的分析过程尽管非常复杂，但写出的代码却非常简洁，这就是数学的魅力。最重要的是，这种算法的时间复杂度是O(n)，空间复杂度是O(1)，因此，无论在时间效率还是在空间效率上都优于第一种方法。

**本题考点：**

- 考查应聘者的抽象建模能力。不管应聘时用环形链表来模拟圆圈，还是分析被删除数字的规律，都要深刻理解这个问题的特点并变成实现自己的解决方案。
- 考查应聘者对环形链表的理解及应用能力。大部分面试官只要求应聘者基于环形的方法解决这个问题。
- 考查应聘者的数学功底及逻辑思维能力。少数对算法和数学基础要求很高的公司，面试官会要求应聘者不能使用O(n)的辅助内存，这时候应聘者就只能静下心来一步步推导出每次删除的数字有哪些规律。

### 面试题63：股票的最大利润

> 题目：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？例如，一只股票在某些时间节点的价格为{9,11,8,5,7,12,16,14}。如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。

股票交易的利润来自股票买入和卖出价格的差价。当然，我们只能在 买入某只股票之后才能卖出。如果把股票的买入价和卖出价两个数字组成 一个数对，那么利润就是这个数对的差值。因此，最大的利润就是数组中 所有数对的最大差值。

我们不难想到用蛮力法来解决这个问题，也就是找出数组中所有的数 对，并逐一求出它们的差值。由于长度为n的数组中存在O(n^2^)个数对，因 此该算法的时间复杂度是O(n^2^)。

 我们也可以换一种思路。我们先定义函数diff(i)为当卖出价为数组中第 i个数字时可能获得的最大利润。显然，在卖出价固定时，买入价越低获得 的利润越大。也就是说，如果在扫描到数组中的第i个数字时，只要我们能 够记住之前的i-1个数字中的最小值，就能算出在当前价位卖出时可能得到 的最大利润。

**本题考点：**

- 考查应聘者的抽象建模能力。应聘者需要从股票买卖的特点入手总 结出股票交易获得最大利润的条件。

- 考查应聘者对数组的编程能力。

## 发散思维能力

 发散思维的特点是思维活动的多向性和变通性，也就是我们在思考问 题时注重运用多思路、多方案、多途径来解决向题。对于同一个问题，我 们可以从不同的方向、侧面和层次，采用探索、转换，迁移、组合和分解 等方法，提出多种创新的解法。 

通过考查发散思维能力，面试官能够了解应聘者探索新思路的激情。 面试时面试官故意限制应聘者不能使用常规的思路，此时他在观察应聘者 有没有积极的心态，是不是能够主动跳出常规思维的束缚从多角度去思考 问题。比如在面试题64“求I+2+……+n“中，面试官有意限制不能使用乘除 法及与循环、条件判断、选择相关的关键字。这个问题应该说是很难的。 在难题面前，应聘者是轻言放弃，还是充满激情地寻找新思路、新方法， 具有不同心态的应聘者在面试中的表现是大不一样的。

 通过考查发散思维能力，面试官能够了解应聘者的灵活性和变通性。 当常规思路遇到阻碍的时候，应聘者能不能及时地从另一个角度用不同的 方法去分析问题，这些都能体现应聘者的创造力。在面试题65“不用加減 乘除做加法”中，当四则运算被限制使用的时候，应聘者能不能迅速地从 二进制和位运算这个方向寻找突破口，都是其思维灵活性的直接体现。 

通过考查发散思维能力，面试官还能了解应聘者知识面的广度和深度。面试实际上是一个厚积薄发的过程。在遇到问题之后，应聘者如果具有宽泛的知识面并且对各领域有较深的理解，那么他就更容易从不冋的角度去 思考问题。比如我们可以从构造函数、虚函数、函数指针及模板参数的实 例化等不同角度去解决面试题64 “求1+2+……+n”。只有对C++各方面的特 性了如指掌，我们才能在遇到问题的时候将各个知识点信手拈来。同样， 如果我们在学习数字电路相关课程的时候对CPU中加法器的原理有深刻的 理解，那么自然就会想到从二进制和位运算的角度去思考解决面试题65“不 用加减乘除做加法。



### 面试题 64：求 1+2+……+n

> 题目：求1+2+……+n，要求不能使用乘除法，for，while，if，else，switch，case等关键字及条件判断语句（A?B:C）

这个问题本身没有太多的实际意义，因为在软件开发中不可能有这么 苛刻的限制。但不少面试官认为这是一道不错的能够考查应聘者发散思维 能力的题目，而发散思维能够反映出应聘者知识面的宽度，以及对編程相 关技术理解的深度。

 通常求1+2+……+n除了用公式n(n+1)/2，无外乎循环和递归两种思路。 由于已经明确限制for和while的使用，循环已经不能再用了。递归函数也 需要用if语句或者条件判断语句来判断是继续递归下去还是终止递归，但 现在题目已经不允许使用这两种语句了 。

- 解法一：利用构造函数求解

   我们仍然围绕循环做文章。循环只是让相同的代码重复执行n遍而已， 我们完全可以不用for和while来达到这个效果。比如我们先定义一个类型， 接着创建n个该类型的实例，那么这个类型的构造函数将确定会被调用n 次。我们可以将与累加相关的代码放到构造函数里。

- 解法二：利用虚函数求解 

  我们同样可以围绕递归做文章。既然不能在一个函数中判断是不是应 该终止递归，那么我们不妨定义两个函数，一个函数充当递归函数的角色， 另一个函数处理终止递归的情况，我们需要做的就是在两个函数里二选 一。从二选一我们很自然地想到布尔变量，比如值为true(1)的时候调用第 一个函数，值为false(0)的时候调用第二个函数。那现在的问题是如何把 数值变量n转换成布尔值。如果对n连续做两次反运算，即!!n，那么非零 的n转换为true。

- 解法三：利用函数指针求解

  在纯C语言的编程环境中，我们不能使用虚函数，此时可以用函数指针来模拟，这样代码可能更加直观一些。

- 解法四：利用模板类型求解

  可以让编译器帮助完成类似于递归的计算

**本题考点：**

 - 考查应聘者的发散思维能力。当习以为常的方法被限制使用的时 候，应聘者是否能发挥创造力，打开思路想出新的办法，是能否通 过面试的关键所在。
 - 考查应聘者的知识面的广度和深度。上面提供的几种解法涉及构造 函数、静态变量、虚拟函数、函数指针、模板类型的实例化等知识 点。只有深刻理解了相关的概念，才能在需要的时候信手拈来。这 就是厚积薄发的过程。

### 面试题65：不用加减乘除做加法

> 题目：写一个函数，求两个整数之和，要求在函数体内不得使用“+”、“-”，“×”，“÷”四则运算符号。

很多人都在想：四则运算都不能用，那还能用什么啊？可是问题总是要解决的，我们只能打开思路去思考各种可 能性。首先我们可以分析人们是如何做十进制加法的，比如是如何得出 5+17=22这个结果的。实际上，我们可以分成三步进行：第一步只做各位相 加不进位，此时相加的结果是12 (个位数5和7相加不要进位是2，十位 数0和1相加结果是1)；第二步做进位，5+7中有进位，进位的值是10； 第三步把前面两个结果加起来，12+10的结果是22,刚好5+17=22。 

我们一直在想，求两数之和四则运算都不能用，那还能用什么？对数 字做运算，除四则运算之外，也就只剩位位运算了。位运算是针对二进制 的，我们就以二进制再来分析一下前面的“三步走”策略对二进制是不是 也适用。

5的二进制任101，17的二进制是10001。我们还是试看把计算分成三 步：第一步各位相加但不计进位，得到的结果是10100（最后一位两个数都 是1，相加的结果是二进制的10。这一步不计进位，因此结果仍然是0）； 第二步记下进位，在这个例子中只在最后一位相加时产生一个进位，结果 是二进制的10；第三步把前两步的结果相加，得到的结果是10110，转换 成十进制正好是22。由此可见“三步走”策略对二进制也是适用的。

接下来我们试着把二进制的加法用位运算来替代。第一步不考虑进位 对每一位相加。0加0、1加1的结果都是0，0加1、1加0的结果都是 1。我们注意到，这和异或的结果是一样的。对异或而言，0和0、1和1的异 或结果是0，而0和1、1和0的异或结果是1 。接着考虑第二步进位，对0 加0、0加1、1加0而言，都不会产生进位，只有1加1时，会向前产生一 个进位。此时我们可以想象成两个数先做位与运算，然后再向左移动一位。 只有两个数都是1的时候，位与得到的结果是1，其余都是0。第三步把前 两个步骤的结果相加。第三步相加的过程依然是重复前面两步，直到不产 生进位为止。

**本题考点：**

- 考查应聘者的发散思维能力。当"+”、"-”、"×”、"÷”运算符都 不能使用时，应聘者能不能打开思路想到用位运算做加法，是能否 顺利解决这个问题的关键。 
- 考查应聘者对二进制和位运算的理解。

**相关问题**

不适用新的变量，交换两个变量的值。比如有两个变量a、b，我们希望交换它们的值。有两种不同的方法：

![image-20200404101752336](E:\document\Learn\CodingInterview\image\image-20200404101752336.png)

### 面试题66：构建乘积数组

> 题目：给定一个数组$A[0,1,\cdots,n-1]$，请构造一个数组$B[0,1,\cdots,n-1]$，其中B中的元素$B[i]=A[0]\times A[1]\times \cdots\times A[i-1]\times A[i+1]\times \cdots\times A[n-1]$。不能使用除法。

如果没有不能使用除法的限制，则可以用公式$\prod^{n-1}_{j=0} A[j]/A[i]$求得$B[i]$。 在使用除法时，要特别注意$A[i]$等于0的情况。

 现在要求不能使用除法，只能用其他方法。一种直观的解法是用连乘 n-1个数字得到$B[i]$。显然这种方法需要O(n^2^)的时间构建整个数组B。 

好在还有更高效的算法。可以把$B[i]=A[0]\times A[1]\times \cdots\times A[i-1]\times A[i+1]\times \cdots\times A[n-1]$看成$A[0]\times A[1]\times \cdots\times A[i-1]$和$A[i+1]\times \cdots\times A[n-1]$两部分的乘积。因此， 数组B可以用一个矩阵来创建（见图6,4）。在图中，现$B[i]$为矩阵中第i行所 有元素的乘积。

不妨定义$C[i]=A[0]\times A[1]\times \cdots\times A[i-1],D[i]=A[i+1]\times \cdots\times A[n-2]\times A[n-1]$。$C[i]$可以用自上而下的顺序计算出来，即$C[i]=C[i-1]\times A[i-1]$。类似的，$D[i]$ 也可以用自下而上的顺序计算出来，即$D[i]=D[i+1]\times A[i+1]$。

**本题考点：**

- 考查应聘者的发散思维能力。这道题目有两种常规解法：一种是把 所有数字都相乘再分别除以各个数字，但题目已经限定不能使用除 法；另一种解法是连乘n-1个数字得到B[i]。通常面试官会告知应 聘者还有比O(n^2^)更高效的算法。此时应聘者不能放弃，还要继续 打开思路，多角度去分析解答问题。
- 考查应聘者对数组的理解和编程能力。

## 本章小结 

面试是我们展示自己综合素质的时候。除了扎实的编程能力，我们还 需要表现自己的沟通能力和学习能力，以及知识迁移能力、抽象建模能力 和发散思维能力等方面的综合实力。

面试官对沟通能力、学习能力的考查贯穿面试的始终。面试官不仅会 留意我们回答问题时的言语谈吐，还会关注我们是否能抓住问题的本质从 而提出有针对性的问题。通常面试官认为善于提问的人有较好的沟通能力 和学习能力。

 知识迁移能力能帮助我们轻松地解决很多问题。有些面试官在提问一 道难题之前，会问一道相关但比较简单的题目，他希望我们能够从解决简 单问题的过程中受到启发，最终解决较为复杂的问题。另外，我们在面试 之前可以做一些练习。如果面试的时候碰到类似的题目，就可以应用之前 的方法。这要求我们平时要有一定的枳累，并且每做完一道题之后都要总 结解题方法。 

有一类很有意思的面试题是从日常生活中提炼出来的，面试官用这种 类型的问题来考査我们的抽象建模能力。为了解决这种类型的问题，我们 先用适当的数据结构表述模型，再分析模型中的内在规律，从而确定计算 方法。

 有些面试官喜欢在面试的时候限制使用常规的思路。这时候就需要我 们充分发挥发散思维能力，跳出常规思路的束缚，从不同的角度去尝试新 的办法。















































