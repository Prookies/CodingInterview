# 解决面试题的思路

## 画图让抽象问题形象化

### 面试题27：二叉树的镜像

> 题目：请完成一个函数，输入一颗二叉树，该函数输出它的镜像。

求一棵树的镜像的过程：先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当交换完所有非叶子节点的左、右子节点之后，就得到了树的镜像。

### 面试题28：对称的二叉树

> 题目：请实现一个函数，用来判断一颗二叉树是不是对称的。如果一颗二叉树和它的镜像一样，那么它就是对称的。

通常我们有3种不同的二叉树遍历算法，即前序遍历、中序遍历和后序遍历。这3种遍历算法都是先遍历左子节点再遍历右子节点。我们可以针对前序遍历定义一种对称的遍历算法，即先遍历父节点，再遍历它的右子节点，最后遍历它的左子节点。通过比较可以发现二叉树的前序遍历序列和对称前序遍历序列来判断二叉树是不是对称的。如果两个序列是一样的，那么二叉树就是对称的。

**本题考点**

- 树的对称是一个抽象的概念，应聘者需要在短时间内想清楚判断对称的步骤并转换为代码。应聘者可以通过画图把抽象的问题形象化。

### 面试题29：顺时针打印矩阵

> 题目：输入一个矩阵，按照从外向里以顺时针依次打印出每一个数字。

由于是以从外圈到内圈的顺序依次打印对的，所以我们可以把矩阵想象成若干个圈。我们可以用一个循环来打印矩阵，每次打印矩阵中的一个圈。

接下来分析循环结束的条件。假设这个矩阵的行数是rows，列数是columns。打印第一圈的左上角的坐标是(0,0)，第二圈的左上角的坐标是(1,1)，以此类推。可以注意到，左上角的坐标中的行和列总是相同的，于是可以在矩阵中选取左上角为(start, start)的一圈作为我们分析的目标。

对于一个5×5的矩阵而言，最后一圈只有一个数字，对应的坐标为(2, 2)。我们发现5>2×2。对于一个6×6的矩阵而言，最后一圈有4个数字，其左上角的坐标仍然为(2, 2)。我们发现6>2×2仍然成立。于是可以得到，让循环继续的条件是colums > startX×2并且rows > startY×2。

接下来考虑如何打印一圈的功能。我们可以把打印一圈分为四步：第一步，从左到右打印一行；第二步，从上到下打印一列；第三步，从右到左打印一行；第四步，从下到上打印一列。每一步我们根据起始坐标和终止坐标用一个循环就能打印出一行或者一列。

不过值得注意的是，最后一圈有可能退化成只有一行、只有一列，甚至只有一个数字，因此打印这样的一圈就不再需要四步。

第一步总是需要的，因为打印一圈至少有一步。如果只有一行，那就不用第二步了。也就是需要第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条件是圈内至少有两行两列，也就是说，除了要求终止行号大于起始行号，还要求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少有三行两列，因此要求终止行号比起始行号至少大于2，同时终止列号大于起始列好。

**测试用例**

数组中有多行多列；数组中只有一行；数组中只有一列；数组中只有一行一列。

**本题考点**

- 从外到内顺时针打印矩阵这个过程非常复杂，应聘者如如何能很快地找出其规律并写出完整的代码，是解这道题的关键。当问题比较抽象不容易理解时，可以试着画几幅图形帮助理解，这样往往能更快地找到思路。

## 举例让抽象问题具体化

当一眼看不出问题中隐藏的规律的时候，我们可以试着用一两个具体的例子模拟操作的过程，这样通过具体的例子找到抽象的规律。

算法通常是很抽象的，用语言不容易表述得很清楚，我们可以考虑举一两个具体的例子，告诉面试官我们的算法是怎么一步步处理这个例子的。

具体的例子还能帮助我们确保代码的质量。在面试中写完代码之后，应该先检查一遍，确保没有问题再交给面试官。我们可以运行几个测试用例。在分析问题的时候采用的例子就是测试用例。我们可以把这些例子当做测试用例，在心中模拟运行，看每一步操作之后的结果和我们预期的是不是一致。如果每一步的结果都和事先预计的一致。那我们就能够保证代码的正确性了。

### 面试题30：包含min函数的栈

> 题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。

看到这个问题，我们的第一反应可能是每次压入一个新元素进栈时，将栈里的所有元素排序，让最小的元素位于栈顶，这样就能在O(1)时间内得到最小元素。但这种思路不能保证最后压入栈的元素能够最先出栈，因此这个数据结构已经不是栈了。

还可能想到在栈里添加一个成员变量存放最小的元素。每次压入一个新元素进栈的时候，如果该元素比当前最小的元素还要小，则更新最小元素。但是当最小的元素被弹出栈了，那么如何得到下一个最小的元素呢？

分析到这里我们发现，仅仅添加一个成员变量存放最小元素是不够的的，也就是说当最小元素被弹出栈的时候，我们希望能够得到次小元素。因此，在压入这个最小元素之前，我们要把次小元素保存起来。

所以可以把每次的最小元素（之前的最小元素和新压入栈的元素两者的较小值）都保存起来放到另外一个辅助栈里。如果每次都把最小元素压入辅助栈，那么就能保证辅助栈的栈顶一直都是最小元素。当最小元素从数据栈内被弹出之后，同时弹出辅助栈的栈顶元素，此时辅助栈的心栈顶元素就是下一个最小值。

**本题考点**

- 在面试的时候，很多应聘者都止步于添加一个变量保存最小元素的思路。其实只要举个例子，多做几次入栈、出栈的操作就能看出问题，并想到也要把最小元素用另外的辅助栈保存。当我们面对一个抽象复杂的问题的时候，可以用几个具体的例子来找出规律。

### 面试题31：栈的压入、弹出序列

> 题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。（压入的元素是否有重复的呢）

解决这个问题很直观的想法就是建立一个辅助栈，把输入的第一个序列中的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。

如果下一个弹出数字刚好是栈顶数字，那么直接弹出；如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到拔下一个需要弹出的数字压入栈顶为止；如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。

**测试用例：**

- 功能测试（输入的两个数组含有多个数字或者只有一个数字；第二个数组是或者不是第一个数组表示的压入序列对应的栈的弹出序列）。
- 特殊输入测试

### 面试题32：从上到下打印二叉树

> 题目一：不分行从上到下打印二叉树
>
> 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

从上到下打印二叉树的规律：每次打印一个节点的时候，如果该节点有子节点，则把该节点放在一个队列的末尾。接下来到队列头部取出最早进入队列的末尾。接下来到队列的头部提取最早进入队列的节点，重复前面的打印操作，直至队列中所有的节点都被打印出来。

**本题考点：**

- 按层从上到下便利二叉树，这对很多应聘者来说是一个新概念，要在短时间内想明白遍历的过程不是一件容易的事情。应聘者通过具体的例子找出其中的规律并想到基于队列的算法，是解决这个问题的关键所在。

**本题扩展：**

> 如何广度优先遍历一幅有向图？同样也可以基于队列实现。树是图的一种特殊退化形式，从上到下按层遍历二叉树，从本质上来说就是广度优先遍历二叉树。

**举一反三：**

> 不关是广度优先遍历一幅有向图还是一棵树，都要用到队列。首先把起始节点（对树而言是根节点）放入队列。接下来每次从队列的头部取出一个节点，遍历这个节点之后把它能到达的节点（对树而言是子节点）都依次放入队列。重复这个遍历过程，直到队列中的节点全部都被遍历为止。



> 题目二：分行从上到下打印二叉树
>
> 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

这道面试题和前面的面试题类似，也可以用一个队列来保存将要打印的节点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前层中还没有打印的节点数：另一个变量表示下一层节点的数目。

> 题目三：之字形打印二叉树
>
> 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二行按照从右到左的顺序打印，第三行在按照从左到右的顺序打印，其他行以此类推。

按之字形顺序打印二叉树需要两个栈。我们在打印某一层的节点时，把下一层的子节点保存在相应的栈里。如果当前打印的是奇数层（第一层、第三层等），则先保存左子节点再保存右子节点到第一个栈里；如果当前打印的是偶数层（第二层、第四层等），则先保存右子节点再保存左子节点到第二个栈里。

**想法：**

可以使用双向列表，这样写的程序将会比参考程序更好。

**本题考点：**

- 按之字形遍历二叉树，这对很多应聘者来说是一个新概念，要在短时间内想明白遍历的过程不是一件容易的事情。应聘者通过具体的例子找出其中的规律并想到两个基于两个栈的算法或者基于双向队列的算法，是解决这个问题的关键。
- 考查应聘者对二叉树，双向队列及栈的理解

### 面试题33：二叉搜索树的后序遍历序列

> 题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。假设输入的数组的任意两个数字都互不相同。

在后序遍历得到的序列中，最后一个数字是熟的根节点的值。数组中前面的数字可以分为两部分：第一部分是左子树节点的值，它们都比根节 点的值小；第二部分是右子树节点的值，它们都比根节点的值大。我们可以用同样的方法确定与数组每一部分对应的子树结构。这其实就是一个递归过程。

**本题考点：**

- 考查应聘者分析复杂问题的思维能力。能否解决这道题的关键在于应聘者能否找出后序遍历的规律。一旦找到了规律，用递归的代码编码相对而言就简单了。在面试的时候，应聘者可以从一两个例子入手，通过分析例子寻找规律。

**相关题目：**

> 输入一个整数数组判断该数组是不是某二叉搜索树的前序遍历结果。 这和前面问题的后序遍历很类似，只是在前序遍历得到的序列中，第一个 数字是根节点的值。

**举一反三：**

>如果面试题要求处理一棵二叉树的遍历序列，则可以先找到二又树的 根节点，再基于根节点把整棵树的遍历序列拆分成左子树对应的子序列和 右子树对应的子序列.接下来再递归地处理这两个子序列。本面试题应用 的是这种思路，面试题7 “重建二叉树”应用的也是这种思路。

### 面试题34：二叉树中和为某一值的路径

> 题目：输入一颗二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶子结点所经过的节点形成一条路径。

由于路径是从根节点出发到叶 节点，也就是说路径总是以根节点为起始点，因此我们首先需要遍历根节 点。在树的前序、中序、后序3种遍历方式中，只有前序遍历是首先访问 根节点的。

当用前序遍历 的方式访问到某一节点时，我们把该节点添加到路径上，并累加该节点的 值。如果该节点为叶节点，并且路径中节点值的和刚好等于输入的整数， 则当前路径符合要求，我们把它打印出来。如果当前节点不是叶节点，则 继续访问它的子节点。当前节点访问结束后，递归函数将自动回到它的父 节点。因此，我们在函数退出之前要在路径上删除当前节点并减去当前节 点的值，以确保返回父节点时路径刚好是从根节点到父节点.我们不难看 出保存路径的数据结构实际上是一个栈，因为路径要与递归调用状态一 致，而递归调用的本质就是一个压栈和出栈的过程。

我们用标准模板库中的vector实现了一个栈来保存路径，每次都用push\_back在路径的末尾添加节点。用pop\_back在路径的末尾删除节点，这样就保证了栈的先入后出的特性。这里没有用STL中的stack的原因是，在stack中只能得到栈顶元素，而我们打印路径的时候 需要得到路径上的所有节点，因此在代码实现的时候std::stack不是最好的 选择。

**本题考点：**

- 考查应聘者分析复杂问题的思维能力。应聘者遇到这个问题的时候，如果一下子没有思路，则不妨从一个具体的例子开始，一步步分析路径上包含哪些节点，这样就能找出其中的规律，从而想到解决方案。

## 分解让复杂问题简单化

在面试中，当我们遇到复杂的大问题的时候，如果能够先把大问题分解成若干个简单的小问题，然后再逐个解决这些小问题，则可能会容易很多。

在计算机领域有一类算法叫分治法，即“分而治之”，采用的就是各个击破的思想。我们把分解之后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。通常分治法都可以用递归的代码实现。

### 面试题35：复杂链表的肤质

> 题目：请实现函数ComplexListNode* Clone(ComplexListNode* pHead)，复制一个复杂链表。在复杂链表中，每个节点除了有一个m\_pNext指针指向下一个节点，还有一个m\_pSibling指针指向链表中的任意节点或者nullptr。

注意：在复杂链表的节点中，除了有指向下一个节点的指针，还有指向任意节点的指针。

听到这个问题之后，很多应聘者的第一反应是把复制过程分成两步： 第一歩是复制原始链表上的每个节点，并用m\_pNext链接起来：第二步是 设置每个节点的m\_pSibling指针。假设原始链表中的某个节点N的 m\_pSibling指向节点S。由于S在链表中可能在N的前面也可能在N的后 面，所以要定位S的位置需要从原始链表的头节点开始找。如果从原始链表的头节点开始沿着m\_pNext经过s步找到节点S。那么在复制链表上节 点N’的m\_pSibling(记为S‘)离复制链表的头节点的距离也是沿着m\_pNext 指针s步。用这种办法就可以为复制链表上的每个节点设置m\_pSibling 指针。

对于一个含有n个节点的链表，由于定位每个节点的m\_pSibling都需 要从链表头节点开始经过O(n)步才能找到，因此这种方法总的时间复杂度 是 O(N^2^)。

由于上述方法的时间主要花费在定位节点的m\_pSibling上面，我们试 着在这方面去进行优化。我们还是分为两步：第一步仍然是复制原始链表 上的每个节点N创建N‘，然后把这些创建出来的节点用m\_pNext链接起来。 同时我们把\<N,N\>的配对信息放到一个哈希表中；第二步还是设置复制链 表上每个节点的m\_pSibling。如果在原始链表中节点N的m\_pSibling指向 节点S，那么在复制链表中，对应的N’应该指向S‘。由于有了哈希表，我 们可以用O(1)的时间根据S找到S'。

 第二种方法相当于用空间换时间。对于有n个节点的链表，我们需要 一个大小为0(n)的哈希表，也就是说我们以0(n)的空间消耗把时间复杂度 由O(n^2^)降低到 O(n)。

接下来我们再换一种思路，在不用辅助空间的情况下实现0(n)的时间 效率。第三种方法的第一步仍然是根据原始链表的毎个节点N创建对应的 N’。这一次，我们把N‘链接在N的后面。

第二步设置复制出来的节点的m\_pSibling。假设原始链表上的N的m\_pSibling指向节点S，那么其对应复制出来的N’是N的m_pNext指向的节点，同样S‘也是S的m_pNext指向的节点。

第三步把这个长链表拆分成两个链表：把奇数位置的节点用m_pNext链接起来就是原始链表，把偶数位置的节点节点用m_pNext链接起来就是复制出来的链表。

**本题考点**

- 考查应聘者对复杂问题的思维能力。本题中的复杂链表是一种不太 常见的数据结构，而且复制这种链表的过程也较为复杂。我们把复 杂链表的复制过程分解成3个步骤，同时把每个步骤都用图形化的 方式表示出来，这样能帮助我们厘清思路。在写代码的时候，我们 为每个步骤定义一个子函数，最后在复制函数中先后调用这3个函 数，有了这些清晰的思路之后再写代码，就容易多了。
- 考查应聘者分析时间效率和空间效率的能力。当应聘者提出第一种 和第二种思路的时候，面试官会提示此时在效率上还不是最优解。 这时候应聘者要能自己分析出这两种算法的时间复杂度和空间复杂度各是多少。

### 面试题36：二叉搜索树与双向链表

> 题目：输入一颗二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

在二叉树中，每个节点都有两个指向子节点的指针。在双向链表中， 每个节点也有两个指针，分别指向前一个节点和后一个节点。由于这两种 节点的结构相似，同时二叉搜索树也是一种排序的数据结构，因此，在理 论上有可能实现：二叉搜索树和排序双向链表的转换。在二叉搜索树中，左 子节点的值总是小于父节点的值，右子节点的值总是大于父节点的值。因 此，我们在将二叉搜索树转换成排序双向链表时，原先指向左子节点的指 针调整为链表中指向前一个节点的指针，原先指向右子节点的指针调整为 链表中指向后一个节点的指针。

由于要求转换之后的链表是排好序的，我们可以中序遍历树中的毎个 节点，这是因为中序遍历算法的特点是按照从小到大的顺序遍历二叉树的 每个节点。我们把树看成3部分：根节点，左子树，右子树。根据排序链表的定义，根节点将和它的左子树的最大一个节点链接起来，同时它还将和右子树最小的节点链接起来。

注：根节点、左子树和右子树。在把左、右子树都转换成排序双向 链表之后再和根节点链接起来，整棵二叉搜索树也就转换成了排序双向 链表。

按照中序遍历的顺序，当我们遍历转换到根节点时，它的左子树己经转换成一个排序的链表了，并且处在链表中的最后一个节 点是当前值最大的节点。我们把当前值最大的节点和根节点链接起来，此时链 表中的最后一个节点就是根节点 了。接若我们去遍历转换右子树，并把根节点 和右子树中最小的节点链接起来。至于怎么去转换它的左子树和右子树， 由于遍历和转换过程是一样的，我们很自然地想到可以用递归。

### 面试题37：序列化二叉树

> 题目：请实现两个函数，分别用来序列化和反序列化二叉树

我们知道可以从前序遍历和中序遍历构造出一颗二叉树。受此启发，我们可以先把一棵二叉 树序列化成一个前序遍历序列和一个中序遍历序列，然后在反序列化时通 过这两个序列重构出原二叉树。

这种思路有两个缺点：一是该方法要求二叉树中不能有数值重复的节 点；二是只有当两个序列中所有数据都读出后才能开始反序列化。如果两 个遍历序列的数据是从一个流里读出来的，那么可能需要等待较长的时间。

实际上，如果二叉树的序列化是从根节点开始的，那么相应的反序列 化在根节点的数值读出来的时候就可以开始了。因此，我们可以根据前序 遍历的顺序来序列化二叉树，因为前序遍历是从根节点开始的。在遍历二 叉树碰到nullptr指针时，这些nullptr指针序列化为一个特殊的字符（如$）。 另外，节点的数值之间要用一个特殊字符（如','）隔开。

总结前面序列化和反序列化的过程，就会发现我们都是把二叉树分解成3个部分：根节点、左子树和右子树。这是典型的把问题递归分解然后逐个解决的过程。

**本题考点**

- 考查应聘者分析复杂问题的能力。为了把这个问题分析清除，我们把树分成3个部分：根节点、左子树和右子树，在序列化/反序列化根节点之后再分别序列化/反序列化左、右子树，因此可以递归解决。解决这个问题的关键在于把一个大的问题分解成几个小问题，并递归解决小问题。

### 面试题38：字符串的排列

> 题目：输入一个字符串，打印出该字符串的所有排列。

如何求出几个字符的所有排列.很多人都不能一下子想出解决方案。 那我们是不是可以考虑把这个复杂的问题分解成小的问题呢？比如，我们 把一个字符串看成由两部分组成：第个部分是它的第一个字符；第二部分 是后面的所有字符。

我们求整个字符串的排列，可以看成两步。第一步求所有可能出现在 第一个位置的字符，即把第一个字符和后面所有的字符交换。第二步是固定第一个 字符，求后面所有字符的排列。这时候我们仍把后面 的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所 有字符。然后把第一个字符逐一和它后面的字符交换。

![image-20200311145933406](E:\document\Learn\CodingInterview\image\image-20200311145933406.png)

**本题考点**

- 考查应聘者的思维能。当整个问题看起来不能直接解决的时候，应聘者能否想到把字符串分成两部分，从而把大问题分解成小问题来解决，是能够顺利解决这个问题的关键。

**本题扩展**

如果不是求字符的所有排列，而是求字符的所有组合，应该怎么办呢？ 还是输入三个字符a、b、c,则它们的组合有a、b、c、ab、ac、be、abc。 当交换字符串中的两个字符时，虽然能得到两个不同的排列，但却是同一 个组合。比如ab和ba是不同的排列，但只算一个组合。 

如果输入n个字符，则这n个字符能构成长度为$1,2,\cdots,n$的组合。在求 n个字符的长度为$m(1\leq m\leq n)$ 的组合的时候，我们把这n个字符分成两 部分：第一个字符和其余的所有字符。如果组合里包含第一个字符，则下 一步在剩余的字符里选取用m-1个字符：如果组合里不包含第一个字符，则 下一步在剩余的n-1个字符里选取m个字符。也就是说，我们可以把求n 个字符组成长度为m的组合的问题分解成两个子问题，分别求n-1个字符中长度为m-1的组合，以及求n-1个字符中长度为m的组合。这两个子问题都可以通过递归的方式解决。

**相关问题**

- 输入一个含有8个数字的数组，判断有没有可能把这8个数字分别 放到正方体的8个顶点上，使得正方体上三组相 对的面上的4个顶点的和都相等。

  这相当于先得到$a_1, a_2, a_3, a_4, a_5, a_6, a_7$和$a_8$这8个数字的所有排列，然后 判断有没有某一个排列符合题目给定的条件，即$a_1+a_2+a_3+a_4=a_5+a_6+a_7+a_8$，$a_1+a_3+a_5+a_7=a_2+a_4+a_6+a_8$，并且$a_1+a_2+a_5+a_6=a_3+a_4+a_7+a_8$。

  ![image-20200312160122768](E:\document\Learn\CodingInterview\image\image-20200312160122768.png)

- 在8x8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两 个皇后不得处在同一行、同一列或者同一条对角线上。图4.20中 的每个黑色格子表示一个皇后，这就是一种符合条件的摆放方法。 请问总共有多少种符合条件的摆法？

  由于8个皇后的任意两个不能处在同一行，那么肯定是每一个皇后 占据一行。于是我们可以定义一个数组Columnlndex\[8\]，数组中第i个 数字表示位于第i行的皇后的列号。先把数组Columnindex的8个数字 分别用0〜7初始化，然后对数组Columnindex进行全排列。因为我们用不 同的数字初始化数组,所以任意两个皇后肯定不同列。只需判断每一个排 列对应的8个皇后是不是在同一条对角线上，也就是对于数组的两个下标i 和j，是否有$i-j=ColumnIndex[i]-ColumnIndex[j]$或者$j-i=ColumnIndex[i]-ColumnIndex[j]$。

  ![image-20200312160833809](E:\document\Learn\CodingInterview\image\image-20200312160833809.png)

## 本章小结

图形能使抽象的问题形象化。当面试题涉及链表、二叉树等数据结构 时，如果在纸上画几张草图，则题目中隐藏的规律就有可能变得很直观。

 一两个例子能使抽象的问题J具体化。很多与算法相关的问题都很抽象， 未必一眼就能看出它们的规律。这时候我们不妨举几个例子，一步一步模 拟运行的过程，说不定就能发现其中的规律，从而找到解决问题的窍门。

把复杂问题分解成若干个小问题，是解决很多复杂问题的有效方法。 如果我们遇到的问题很大，则可以尝试先把大问题分解成小问题，然后再 递归地解决这些小问题。分治法、动态规划等方法应用的都是分解复杂问题的思路.



































